#import "template.typ": *

= 向量 <vec:chapter>

*线性表*是指相同类型的有限个数据组成的_序列_。
本书按照@邓俊辉2013数据结构 的方法，将线性表分为*向量*（vector）和*列表*（list）两种形式，分别对应C++中的`std::vector`和`std::list`。在另一些教材@严蔚敏1997数据结构 中，这两个词被称为*顺序表*和*链表*，分别对应Java里的`ArrayList`和`LinkedList`。向量（顺序表）和列表（链表）这两对概念通常可以混用。
向量和列表代表着两种最基本的数据结构组织形式：*顺序结构*和*链式结构*。本章介绍顺序结构的线性表，即向量。

== 线性表 <vec:linear-list>

对比线性表和一般的数据结构。一般的数据结构的定义中，数据被组织为“某种结构化的形式”，而在线性表这里它被具体化为了“序列”。既然是序列，那么它会具有头和尾，会具有“第$i$个”这样的概念；每个元素有它在序列上的“上一个”和“下一个”元素。这是一个朴素的想法，从数学角度容易理解。但从计算机的角度，请您思考这样的问题：“元素”应该用什么表示？应该如何找到序列中的一个元素呢？

把计算机中的内存想像为一座巨大的旅馆，线性表是一个居住在其中的旅游团。现在旅游团预定了一大片连续的房间，比如，从1000到1099，并且让第1个游客住在1000，第2个游客住在1001，以此类推，那么我们就很方便地可以知道第$i$个游客的房间号。这种情况下，我们只需要知道游客的序号，就能知道它们居住的房间号。但并不是每个人都会按部就班地居住，一些人可能喜欢阳光，一些人可能想和伙伴们做邻居，于是，这些游客开始交换房间。房间被交换之后，我们再也无法直接知道第$i$个游客的房间号。一个可能的想法是，从1000到1099每一个房间都敲敲门。这种方法虽然可行，但无疑是很低效的。更加糟糕的是，旅游团可能没订到连续的房间，游客们散落在旅馆的各处。因为我们不可能像推销员那样每个房间都敲门（这会被赶出去的），所以再也无法找到我们想要的第$i$个游客了。为了应对这种情况，旅游团的导游往往会记录下各个游客所在的房间号，以便能够找到他们。

在上面这个比喻中，我们可以看到，如果数据结构中的元素被连续地储存，那么我们可以通过它们的序号（称为秩 @邓俊辉2013数据结构，rank）来找到它们；如果数据结构中的元素并没有被连续地储存，则我们只能通过它们的位置（position）来找到它们。上面的三种情况，分别是地址连续、且地址和秩相关的顺序结构（向量）；地址连续、但地址和秩无关的静态链式结构（静态链表）；地址不连续、也和秩无关的动态链式结构（动态链表）。@fig:vec1 示意了三种结构的区别。

#figure(
    image("images/sum1.svg", width: 100%),
    caption: "向量、静态链表和动态链表的对比",
) <fig:vec1>

显然，如果发生了第二种情况，导游通常还是会选择记录房间号而不是逐个敲门。那么既然没有省事，也就没有必要预定一大片房间了。因为旅馆老板（也就是操作系统）可能会乘机宰客。比如，旅游团一次定了100个房间，但中途有50人提前结束了旅行。由于旅游团定的是整单，老板不允许单独退这50个人的房间。于是，旅游团要么承担50间空房的代价（空间损失）；要么再定50个房间，请剩下的50人搬到新房间住（时间损失），然后把原来的100个房间一并退掉。从这个例子中可以看到，静态链表是一个不实用的数据结构，本书将把重点聚焦在向量和动态链表（列表）上。

如前所述，向量和列表里定位元素的方法是不同的。向量是循秩访问，而列表则循位置访问。因此，我们设计的线性表抽象类中需要反映这一点。