#import "template.typ": *

= 向量 <vec:chapter>

*线性表*是指相同类型的有限个数据组成的_序列_。
本书按照@邓俊辉2013数据结构 的方法，将线性表分为*向量*（vector）和*列表*（list）两种形式，分别对应C++中的`std::vector`和`std::list`。在另一些教材@严蔚敏1997数据结构 中，这两个词被称为*顺序表*和*链表*，分别对应Java里的`ArrayList`和`LinkedList`。向量（顺序表）和列表（链表）这两对概念通常可以混用。
向量和列表代表着两种最基本的数据结构组织形式：*顺序结构*和*链式结构*。本章介绍顺序结构的线性表，即向量。

== 线性表 <vec:linear-list>

对比线性表和一般的数据结构。一般的数据结构的定义中，数据被组织为“某种结构化的形式”，而在线性表这里它被具体化为了“序列”。既然是序列，那么它会具有头和尾，会具有“第$i$个”这样的概念；每个元素有它在序列上的“上一个”和“下一个”元素。这是一个朴素的想法，从数学角度容易理解。但从计算机的角度，请您思考这样的问题：“元素”应该用什么表示？应该如何找到序列中的一个元素呢？

把计算机中的内存想像为一座巨大的旅馆，线性表是一个居住在其中的旅游团。现在旅游团预定了一大片连续的房间，比如，从1000到1099，并且让第1个游客住在1000，第2个游客住在1001，以此类推，那么我们就很方便地可以知道第$i$个游客的房间号。这种情况下，我们只需要知道游客的序号，就能知道它们居住的房间号。但并不是每个人都会按部就班地居住，一些人可能喜欢阳光，一些人可能想和伙伴们做邻居，于是，这些游客开始交换房间。房间被交换之后，我们再也无法直接知道第$i$个游客的房间号。一个可能的想法是，从1000到1099每一个房间都敲敲门。这种方法虽然可行，但无疑是很低效的。更加糟糕的是，旅游团可能没订到连续的房间，游客们散落在旅馆的各处。因为我们不可能像推销员那样每个房间都敲门（这会被赶出去的），所以再也无法找到我们想要的第$i$个游客了。为了应对这种情况，旅游团的导游往往会记录下各个游客所在的房间号，以便能够找到他们。

在上面这个比喻中，我们可以看到，如果数据结构中的元素被连续地储存，那么我们可以通过它们的序号（称为秩 @邓俊辉2013数据结构，rank）来找到它们；如果数据结构中的元素并没有被连续地储存，则我们只能通过它们的位置（position）来找到它们。上面的三种情况，分别是地址连续、且地址和秩相关的顺序结构（向量）；地址连续、但地址和秩无关的静态链式结构（静态链表）；地址不连续、也和秩无关的动态链式结构（动态链表）。@fig:vec1 示意了三种结构的区别。

#figure(
    image("images/vec1.svg", width: 90%),
    caption: "向量、静态链表和动态链表的对比",
) <fig:vec1>

显然，如果发生了第二种情况，导游通常还是会选择记录房间号而不是逐个敲门。那么既然没有省事，也就没有必要预定一大片房间了。因为旅馆老板（也就是操作系统）可能会乘机宰客。比如，旅游团一次定了100个房间，但中途有50人提前结束了旅行。由于旅游团定的是整单，老板不允许单独退这50个人的房间。于是，旅游团要么承担50间空房的代价（空间损失）；要么再定50个房间，请剩下的50人搬到新房间住（时间损失），然后把原来的100个房间一并退掉。从这个例子中可以看到，静态链表是一个不实用的数据结构，本书将把重点聚焦在向量和动态链表（列表）上。如前所述，向量和列表里定位元素的方法是不同的。向量是循秩访问，而列表则循位置访问。我们通过传入不同的迭代器类型参数来控制这两种访问方式。

```cpp
template <typename T, typename It, typename CIt>
class LinearList : public DataStructure<T> {
public:
    using value_type = T;
    using iterator = It;
    using const_iterator = CIt;

    virtual iterator insert(const_iterator p, const T& e) = 0;
    virtual iterator insert(const_iterator p, T&& e) = 0;
    virtual iterator erase(const_iterator p) = 0;
    virtual const_iterator find(const T& e) const = 0;
    virtual void clear() = 0;
};
```
#graybox[【C++学习】#linebreak()#h(2em)
完整的一个STL容器（哪怕是`std::array`）是非常复杂的，感兴趣的读者可自行阅读其源码。本书的示例代码是一个简化的版本。

*右值引用*（rvalue reference）被用于实现移动语义，即将一个对象的资源（比如内存）袋子_移动_到另一个对象的袋子里，而不是_复制_同样的一份资源。这样可以避免不必要的内存分配和释放，提高程序的性能。容易复制的类型，如基本类型和简单结构体，通常不需要使用右值引用。
]

#graybox[
#h(2em)传统的左值引用通常使用`T&`表示，而右值引用则使用`T&&`表示。以上面示例代码中的两个版本`insert`为例。假设`L`是一个元素类型为`T`的线性表对象：
```cpp
T a {};
L.insert(L.end(), a); // insert(const_iterator, const T&)
L.insert(L.end(), std::move(a)); // insert(const_iterator, T&&)
L.insert(L.end(), T{}); // insert(const_iterator, T&&)
```
#h(2em)当`e`传入一个对象`a`时，`insert`会调用左值引用的版本，因为在`a`被插入的线性表之后，我们希望线性表中的元素`L.back()`和原有的元素`a`是两个不同的元素，也就是说我们希望在`a`所使用的资源之外，再增加一份资源用于`L`中新加入的元素。而当`e`传入_被移动的_对象`std::move(a)`时，后续我们不会再通过`a`访问这个元素，因此我们可以把`a`的资源直接移动到`L`中，而不需要再分配一份新的资源；所以这个时候会调用右值引用的版本。最后，当`e`传入一个_临时对象_`T{}`时，`T{}`是一个临时对象，它的资源不会被其他对象使用，因此我们可以直接移动它的资源到`L`中，也调用右值引用的版本。

*迭代器*（iterator）是STL广泛使用的一种设计模式。迭代器是一个对象，它可以指向容器中的一个元素，也可以通过一些操作来访问容器中的元素，类似于一个带封装的指针。迭代器的设计使得STL的算法可以独立于容器的具体实现。由于迭代器和《数据结构》中的知识点无关，本书中的数据结构会使用一个简化版本的迭代器，以使得一些STL算法以及`range-based for`可以被用于本书中的数据结构。在上面的示例代码中，`const_iterator`是一个只读的迭代器，即被它指向的容器元素不能被修改，而`iterator`是一个可读可写的迭代器。使用迭代器，可以通过如下方式遍历一个`std::vector`对象`V`（以下三种方式是等价的）：
```cpp
for (auto i { 0uz }; i < L.size(); ++i) { visit(V[i]); } // visit by rank
for (auto i { V.begin() }; i != V.end(); ++i) { visit(*i); } // visit by iterator
for (auto& e : V) { visit(e); } // visit by range-based for
```
]

== 向量的结构 <vec:structure>

*向量*（vector）是一个基于*数组*（array）的数据结构。和数组一样，它在内存中占据的是一段连续的空间。#linebreak()
#graybox[#h(2em)
C++建议更多地使用标准库中的向量容器`std::vector`代替数组。向量和数组相比，其最重要的区别在于它是运行时_可变长的_，而在其他使用上，二者基本可以等同。因此，向量上的算法可以很容易地修改为数组上的算法（即使不使用`std::span`）。向量的时间和空间性能和数组相比都只有常数的差异，不会有复杂度的区别，且在大多数场景下二者的性能差异并不显著。因此，除非数组的大小具有确定的语义，否则总是可以使用`std::vector`代替数组。]

作为一种基于数组的线性表，_向量的元素次序和数组的元素次序相同_。如果一个向量`V`基于长度为$n$的数组`A`构建，那么向量`V`的第`i`个元素就是`A[i]`。众所周知，C语言的数组可以视为指针，于是向量`V`的第`i`个元素的地址就是`A+i`。

向量里的元素数量$n$，称为向量的*规模*（size）；而向量所占有的连续空间能够容纳的元素数量$m$，称为向量的*容量*（capacity）。这两者通常是不同的，规模必定不大于容量，而在不超过容量的前提下，向量的规模可以灵活变化，从而赋予了它比数组更高的灵活性。@vec:linear-list 中的旅行团例子也可以帮助理解规模和容量的关系：一个$n$人的旅行团订了连续的$m$个房间，这里$m$可以大于$n$，这样，如果旅行过程中有新人加入团队，他们就可以直接加入到已经预定的连续房间中来。

#figure(
    image("images/vec2.svg", width: 90%),
    caption: "向量、静态链表和动态链表的对比",
) <fig:vec2>

如@fig:vec2 所示，
对于向量中的每一个元素`V[i]`来说，它前面的元素称为它的*前驱*（predecessor），它后面的元素称为它的*后继*（successor）。特别地，和它位置相邻的前驱，也就是*直接前驱*为`V[i-1]`，相应地，*直接后继*为`V[i+1]`。所有的前驱构成了*前缀*（prefix），也就是`V[0:i]`；所有的后继构成了*后缀*（suffix），也就是`V[i+1:n]`。本书中我们用`V[a:b]`来简记`V[a],V[a+1],...,V[b-1]`这个子序列，这是Python的切片（slice）语法，借助它可以简化很多叙述，尤其在记忆一些比较复杂的算法时很有用。

== 循秩访问 <vec:rank-access>

向量的核心特征是*循秩访问*（access by rank）。称元素`V[i]`在向量`V`中的序号`i`为它的*秩*（rank）。对于建立在数组`A`上的向量`V`，因为`V`和`A`的元素次序是一致的，所以`V[i] = A[i] = *(A+i)`。因此，只要知道一个元素的秩，就可以在$O(1)$的时间内访问该元素。因为下标（秩）总是非负的，所以我们用`std::size_t`类型来存储它。

接下来，我们开始构筑向量抽象类。首先，除了在`DataStructure`里定义的规模`size`之外，我们还需要定义容量`capacity`。同时，因为向量是可变长的，所以规模和容量都是可以变化的，还需要两个修改它们的方法。有了修改规模的方法，线性表里的`clear`就可以直接用`resize(0)`实现。其次，我们需要构筑循秩访问的功能，通过重载`operator[]`方法，像访问数组一样访问向量中的元素。

```cpp
template <typename T>
class AbstractVector : public LinearList<T, /* iterators */> {
protected:
    virtual T* data() = 0;
public:
    virtual std::size_t capacity() const = 0;
    virtual void reserve(std::size_t n) = 0;
    virtual std::size_t size() const = 0;
    virtual void resize(std::size_t n) = 0;
    T& operator[](std::size_t r) { // definition (1)
        return data()[r];
    }
    const T& operator[](std::size_t r) const { // definition (2)
        return data()[r];
    }
};
```

#graybox[【C++学习】#linebreak()#h(2em)
在类的成员函数之后加上`const`关键字，表示这个成员函数是一个_只读_的成员函数，它不会修改对象的状态。这样的成员函数可以被`const`对象调用，也可以被非`const`对象调用。但是，`const`对象不能调用非`const`成员函数，因为这些函数可能修改对象的状态。

这会带来一个问题，以`operator[]`为例，当向量`V`是`const`对象时，按照上述定义（1）的`operator[]`无法被调用，也就是说我们无法通过`V[r]`的方式去访问向量中的元素。反之，如果只采用定义（2），那么`const`对象固然可以调用`operator[]`了，但是返回的`V[r]`是一个可修改的元素，这就违背了`const`的语义。

为了解决这个问题，C++引入了`const`成员函数的重载。我们可以引入一个`const`版本的`operator[]`，它返回的是一个只读的元素。这样，`const`对象可以通过`V[r]`的方式去访问向量中的元素，而且返回的元素是只读的。当然这样还有一个编程效率上的小问题，就是我们需要写两个完全相同的函数体。这个问题在C++23引入“`this`捕获器”特性之后得以解决；本书目前使用的编译器暂时不支持该特性。
```cpp
template <typename Self>
auto&& operator[](this Self&& self, std::size_t r) {
    return std::forward<Self>(self).data()[r];
}
```
]

#graybox[
#h(2em)最后，操作底层内存的时候因为不能获得所有权，所以不能使用智能指针，只能使用裸指针。为了避免裸指针被外部获取，我们将向量的获取首地址方法`data()`设置为`protected`，这样只有子类可以访问它。]

现在，我们已经拥有了一个抽象类`AbstractVector`，它被称为*抽象数据类型*（Abstract Data Type，ADT）。它还缺少下面这些组件的实现：获取规模、容量和首地址的方法；修改规模和容量的方法；插入、删除、查找的方法。如果读者打算自己实现向量类，只需要在抽象类的基础上补充它们即可；读者也可以继承本书提供的示例向量类，重写其中的部分方法。以下将展示本书的示例实现。

```cpp
template <typename T>
class Vector : public AbstractVector<T> {
protected:
    std::unique_ptr<T[]> m_data { nullptr };
    std::size_t m_capacity { 0 };
    std::size_t m_size { 0 };

    T* data() override { return m_data.get(); }
    const T* data() const override { return m_data.get(); }
public:
    std::size_t capacity() const override { return m_capacity; }
    std::size_t size() const override { return m_size; }
};
```

#graybox[【C++学习】#linebreak()#h(2em)
C++14起，允许用户使用智能指针管理数组，因此我们使用`std::unique_ptr`来申请内存。它的主要好处是不需要在析构函数里手动释放，减少了手动管理内存的麻烦。本书中若无特殊情况，将总是使用智能指针来表示所有权，避免在任何地方使用`delete`关键字释放内存。
]

== 向量的容量和规模 <vec:capacity-size>

=== 初始化 <vec:capacity-size:init>

当我们建立一个新的数据结构的时候，有几种情况是比较典型的，应当实现相应的构造函数。在这里，以向量为例展示它们，后面讨论其他的数据结构的时候不再赘述。

*零初始化*。即，生成一个空的数据结构。对于向量来说，这应该包含一个大小为0的数组，并把容量和规模都赋值为0。然而，C++不支持大小为0的数组，所以只能将`data`赋值为`nullptr`，就像在@vec:rank-access 中展示的默认值那样。

*指定大小的初始化*。即，给定$n$，生成一个规模为$n$的数据结构，其中的每个元素都采用默认值（即元素采用零初始化）。对于向量而言，可以申请一片大小为$n$的内存，如下面的代码所示。
```cpp
Vector(std::size_t n) : m_data { std::make_unique<T[]>(n) }
                      , m_capacity { n }
                      , m_size { n } {}
```

#h(2em)*复制初始化*。即，给定相同数据结构的一个对象，复制该对象里的所有数据及数据之间的结构化关系。对于向量来说，只需要在申请大小为$n$的内存之后，将给定的向量的元素逐一复制进来即可。注意这里在初始化器中显式调用了上面的“指定大小的初始化”的构造函数，为向量进行了初步的初始化，然后再把另一个向量的数据复制进来。
```cpp
Vector(const Vector& other) : Vector(other.m_size) { 
    std::copy_n(other.m_data.get(), other.m_size, m_data.get());
}
```

#h(2em)*移动初始化*。即，给定相同数据结构的一个对象，将该对象里的所有数据及数据之间的结构化关系移动到当前对象处。如前所述，*移动*（move）语义和复制（copy）有显著的不同，因为在移动之后，“被移动”的对象失去了对数据的所有权，我们永远不会从被移动后的对象里访问那些数据。
```cpp
Vector(Vector&& other) noexcept : m_data { std::move(other.m_data) }
                                , m_capacity { other.m_capacity }
                                , m_size { other.m_size } {
        other.m_capacity = 0;
        other.m_size = 0;
    }
```

#graybox[【C++学习】#linebreak()#h(2em)
移动构造函数和移动赋值运算符通常被声明为`noexcept`，因为如果一个对象在移动过程中抛出异常，那么该对象可能处于一个无效的状态。而由于移动语义的设计，源对象在移动操作后可能不再保留其原有状态，这使得异常处理变得困难。此外，应当避免抛出异常的析构函数也通常被声明为`noexcept`。

通过对智能指针调用`std::move`，我们可以在常数时间内，将被移动对象的数据转移到新对象里。被移动之后，`other`的数据区被复位为空指针，规模和容量都被置0，就像它被零初始化了一样，成为了一个空向量。

从@fig:vec3 中可以直观了解到复制和移动的语义区别。当数据结构里的元素数量很多时，逐元素地复制是一项复杂、琐碎、漫长的工程，而移动则是一项简单、整体、快速的工作。在本书的示例代码中，我们经常会给同一个函数提供一个复制版本和一个移动版本。
]

#figure(
    image("images/vec3.svg", width: 100%),
    caption: "复制和移动的语义区别",
) <fig:vec3>

#graybox[
#h(2em)比如，对于插入（`insert`），我们定义一个插入`const T&`类型的方法用于复制（不破坏源），又定义了一个插入`T&&`类型的方法用于移动（破坏源）。这些方法之间往往只有一个或几个`std::move`的区别，因此本书通常省略移动版本的方法，而只展示复制版本的方法。尽管如此，在读者的日常编程中需要注意，只要复制和移动的时间成本_有可能_相差比较远，就应该同时定义并实现复制和移动两个版本的方法，而不应该只实现复制。

需要注意的是，析构函数、复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符这5个函数，一旦显式定义其中的一个（比如想要定义复制构造函数），编译器就不会自动生成其他的函数。处于“一荣俱荣，一损俱损”的关系。因此，我们在日常编程的时候，通常选择不实现它们中间的任意一个函数（0原则，rule of zero）。因为日常编程的时候，通常都使用的是STL对象，而STL里已经将这些功能实现了。但是，在我们实现一些比较底层的结构时候，没法依靠STL里的实现，需要实现这5个函数中的一个或几个。此时，就必须要将所有的5个函数实现（5原则，rule of five）。我们可以使用`=default`来显式使用自动生成的函数，但如果我们不显式说明它，这些函数将不会被包含在这个类中。
]

*初始化列表初始化*。即，使用初始化列表`std::initializer_list`对数据结构进行初始化。初始化列表也是一个典型的容器，可以直接使用STL方法移动。

```cpp
Vector(std::initializer_list<T> ilist) : Vector(ilist.size()) {
    std::move(ilist.begin(), ilist.end(), m_data.get());
}
```

#graybox[
#h(2em)支持初始化列表初始化之后，我们就可以用下面的形式来初始化一个向量（正如`std::vector`一样）。
```
Vector V { 1, 2, 3 };
```
]

=== 装填因子 <vec:capacity-size:load-factor>

设向量的容量为$m$，规模为$n$，则称比值$n / m$为*装填因子*（load factor）。正常情况下，这是一个$[0,1]$之间的数。装填因子是衡量向量效率的重要指标。

+ 如果装填因子_过小_，则会造成内存浪费：申请了巨大的数组，但其中只有少量的单元被向量中的元素用到，其他单元都被闲置了。
+ 如果装填因子_过大_（超过1），则会引发数组越界，造成_段错误_（segmentation fault）。

#h(2em)
刚开始时，装填因子一定在$[0,1]$之间。
但因为数组的容量$m$是固定的，而向量的规模$n$是动态的，所以一开始分配的$m$可能后来会不够用，从而产生装填因子大于1的问题，此时就需要令$m$增大，这一操作称为*扩容*（expand）。相反，如果向量的规模$n$变得很小，那么$m$可能会远大于$n$，这时就需要令$m$减小，这一操作称为*缩容*（shrink）。扩容和缩容的操作都是需要花费时间的，因此我们希望尽量减少它们的发生次数。在对时间性能要求非常严格的场景下（如算法竞赛），有可能禁止扩容和缩容，转为预先分配足够大的内存，这样可以避免动态分配内存的时间开销。

在一般场景下，扩容是非常常见的操作，但现实中很少进行缩容。扩容和缩容都需要时间，在扩容的场合是实现可变长特性的必需，但在缩容的场合仅仅是节约了空间而已。有多个原因让我们不愿意实现缩容：
    + 我们可以接受一定程度的空间浪费，因为很少有程序能占满全部的内存。
    + 如果缩容之后，又因为规模扩大而不得不扩容，一来一回浪费了不少时间，而价值甚微。
    + 当不得不考虑空间时，我们有_手动缩容_的备用方案。即，复制初始化生成一个新向量，然后清空原向量来释放内存；按照之前介绍的方法，这个新向量的装填因子为1，处在空间最大利用的状态。

#h(2em)因此，本书的示例代码中没有实现缩容。

=== 扩容 <vec:capacity-size:expand>

无论是扩容还是缩容，我们都需要重新申请一片内存。在扩容的场合，这很好理解。我们预定了1000到1099的房间，但在我们预定之后，1100号房间可能被其他旅客占用了。这时如果我们想要预定连续的200个房间，就需要重新找一段空房间。缩容的场合，则是为了安全性考虑，不允许释放数组的部分内存。重新申请内存之后，我们将数据复制到新内存中。下面是扩容的一个实现。

```cpp
void reserve(std::size_t n) override {
    if (n > m_capacity) {
        auto tmp { std::make_unique<T[]>(n) };
        std::move(m_data.get(), m_data.get() + m_size, tmp.get());
        m_data = std::move(tmp);
        m_capacity = n;
    }
}
```

#figure(
    image("images/vec4.svg", width: 100%),
    caption: "扩容的过程",
) <fig:vec4>


@fig:vec4 展示了当插入元素时如果发现容量不足，所进行的扩容过程。其中释放原先的内存这一步，本书中所采用的智能指针会自动完成，而C语言和旧标准C++则需要显式地`delete[]`释放内存。

可以看出，扩容是一项成本很高的操作，因为它需要开辟一块新的内存。设扩容之后的容量为$m$，则扩容算法的时间复杂度为$Theta(m)$。由于$m$可能会很大，我们不希望经常扩容。在@vec:capacity-size:arithmetic-geometric 里将会讨论一些扩容策略。

```cpp
void resize(std::size_t n) override {
    if (n > m_capacity) {
        reserve(n);
    }
    m_size = n;
}
```

#h(2em)如上所述，我们还设计了一个方法`resize`用来改变规模，当规模超过容量（装填因子超过1）的时候调用`reserve`扩容。需要注意的是，一些其他的方法也会改变规模，比如插入方法`insert`会让规模增加1，而删除方法`remove`会让规模减1。我们需要在实现插入方法的时候也考虑扩容问题；_如果实现了缩容，那么在实现删除方法的时候也需要考虑缩容问题_。

=== 扩容策略 <vec:capacity-size:expand-strategy>

当我们调用`resize`的时候，可以立刻知道，需要扩大到多少容量才能容纳目标的规模。但实际情况下，很多时候元素是被一个一个加入到向量中的，这个时候，按照`resize`的策略，每次都扩容到新的规模，是一个糟糕的选择。假设初始化为了一个规模为$n$的向量，然后元素一个一个被加入，那么按照$n arrow.r n+1 arrow.r n+2 arrow.r ...$的次序扩容，每加入一个元素，都会造成至少$n$个元素的复制，时间效率极差。

因此，在面对持续插入的时候，我们需要设计新的扩容策略，以降低扩容发生的频率。这个策略应该是由向量的设计者提供的，而不是用户：如果用户知道更加合适的策略，他们会主动使用`reserve`进行手动扩容。但是，用户通常没有精力用在这种细节上；这个时候，向量的设计者提供的自动扩容策略就会成为一个不错的备选项。

现在我们尝试为扩容策略的问题添加一个抽象的描述。当我们讨论扩容的时候，显然不需要知道向量中的数据内容是什么。因此，扩容策略作为一个算法，输入向量的当前规模$n$和当前容量$m$，输出新的容量$m'$。_这个描述具有良好的可重用性，它同样可以用于缩容。_

```cpp
class VectorAllocator : 
    public Algorithm<std::size_t(std::size_t, std::size_t)> {
protected:
    virtual std::size_t expand(std::size_t capacity
                             , std::size_t size) const = 0;
    virtual std::size_t shrink(std::size_t capacity
                             , std::size_t size) const {
        return capacity;
    }
public:
    std::size_t operator()(std::size_t capacity
                         , std::size_t size) override {
        if (capacity <= size) {
            return expand(capacity, size);
        } else {
            return shrink(capacity, size);
        }
    }
};
```

#h(2em)
基于上述的分析，我们可以用这个类表示容量改变的策略。在@vec:capacity-size:arithmetic-geometric，将继承这个类并重写`expand`方法，以实现不同策略的扩容。缩容方法则直接返回`capacity`（永不缩容）；如果需要实现缩容的时候，也可以使用这个模板，重写`shrink`方法。

#pagebreak()#h(2em)
=== 等差扩容和等比扩容 <vec:capacity-size:arithmetic-geometric>

那么，应该如何设计扩容策略呢？一个简单的想法是，既然每次容量+1不行，那就加多一点。这种思路可以被概括为_等差数列_扩容方法。如果选取$d$作为公差，那么在本节开始的那个例子中，将按照$n arrow.r n+d arrow.r n+2d arrow.r ...$的次序扩容。

```cpp
template <std::size_t D> requires (D > 0)
class VectorAllocatorAP : public VectorAllocator {
protected:
    std::size_t expand(std::size_t capacity
                     , std::size_t size) const override {
        return capacity + D;
    }
};
```

#graybox[【C++学习】#linebreak()#h(2em)
`requires`表示模板参数必须要满足后面的条件，否则无法通过编译。当`D`为0时，等差数列扩容的公差是0，这是一个无意义的操作，因此我们禁止这种情况的发生。使用`requires`代替传统的`std::enable_if`有助于简化在模板元编程中限制，有助于更好地实现SFINAE（Substitution Failure Is Not An Error）原则。

SFINAE原则是模板元编程中的重要原则。当使用了SFINAE实现对于同一个函数模板的多个重载时，对于函数模板的每一个实例，编译器会尝试将实参代入到模板参数中，如果代入失败，编译器会尝试下一个重载，而不是报错。比如，我们可以同时定义带有`requires std::is_same_v<T, int>`以及`requires std::is_same_v<T, std::string>`的两个重载，当传入一个`int`时，编译器会选择第一个重载，而传入一个`std::string`时，编译器会选择第二个重载。
]

既然有了等差数列，另一个很容易想到的方法是按照_等比数列_扩容。如果选取$q$作为公比，则会按照$n arrow.r q n arrow.r q^2n arrow.r ...$的次序扩容。

```cpp
template <typename Q> requires (Q::num > Q::den)
class VectorAllocatorGP : public VectorAllocator {
protected:
    std::size_t expand(std::size_t capacity
                     , std::size_t size) const override {
        std::size_t newCapacity { capacity * Q::num / Q::den };
        return std::max(newCapacity, capacity + 1);
    }
};
```

#graybox[
#h(2em)这里允许了C++11提供的编译期有理数`std::ratio`作为模板参数，`Q::num`表示分子，而`Q::den`表示分母。
]

请注意，需要保证新的容量比原有容量大，否则扩容就没有意义。上面的做法保证了容量至少会扩大1。比如，当$Q=3/2$，往容量为0的向量里连续插入元素时，容量变化为$0 arrow.r 1 arrow.r 2 arrow.r 3 arrow.r 4 arrow.r 6 arrow.r 9 arrow.r ...$，如果没有容量至少扩大1的设计，等比扩容将永远停留在0容量。

=== 分摊复杂度分析 <vec:capacity-size:amortized-analysis>

很显然，进行单次扩容操作的时候，等差扩容的时间复杂度为$O(n+d) = O(n)$，等比扩容的时间复杂度为$O(q n) = O(n)$（因为$q$是常数），两者看起来没有区别；甚至和我们已经知道效率很低的情况（$d=1$的等差扩容）也没有区别。这也意味着，我们评价时间效率的方法可能出现了一些问题。

问题的关键在于，我们设计扩容策略的目的是按照等差或等比的_数列_扩容，而不是_一次_扩容。所以，评价这两种扩容规则的标准，不是进行一次扩容的效率或进行一次扩容后的装填因子，而是比较一系列扩容操作的总体效率和在这一系列扩容操作中的平均装填因子。用已有的复杂度分析工具不足以对这两种策略的效率进行准确评价。
为了对_一系列_操作进行分析，需要引入新的复杂度分析标准。

一般地，假设$O_1, O_2, ..., O_n$是连续进行的$n$次操作，则当$n arrow.r infinity$，这$n$次连续操作所用时间的_平均值_的复杂度，称为这一操作的*分摊复杂度*（amortized complexity），对分摊复杂度的分析称为*分摊分析*。分摊分析的原则之一是：_使用相同效果的操作序列_。所以，要比较上述两种算法，不应该把每次操作取为“进行一次扩容”（因为两种方法扩容量不一样），而应该取为“向量`V`的规模增加$1$”。连续进行$n$次操作，就可以考虑向量`V`的规模从$0$增长为$n$的过程。

在等差扩容方法中，容量依次被扩充为$d,2d,3d,...,n$，共进行$n/d$次扩容。
因此，分摊复杂度为：
$
T(n) = (d + 2d + 3d + ... + n) / n 
     = 1 / 2 dot (d / n + 1) dot (n / d) 
     = Theta(n / d)
$

#h(2em)
另一方面，从空间效率的角度，进行$k$次扩容之后的装填因子至少为$(k d ) / ((k+1) d)=k / (k+1)$，当$k arrow.r infinity$时，装填因子趋于100%。

而在等比扩容方法中，容量被依次扩充为$q,q^2,q^3, ...,n$，共进行$log _q n$次扩容。因此，分摊复杂度为：
$
T(n) = (q + q^2 + q^3 + ... + n) / n 
     = q / (q-1)
     = O(1)
$

#h(2em)
另一方面，装填因子不断在$[1 / q,1]$之间线性增长，平均装填因子为$(1+q) / (2q)$。可以看出，不管怎样选择$q$，对分摊复杂度都没有影响，而更小的$q$能够带来更大的平均装填因子。当选择$q=2$时，平均装填因子为75%。

可以看出，等比扩容的装填因子并没有很低，而换来了分摊时间复杂度上巨大的优化。因此，我们倾向于选择等比扩容。至于等比扩容的公比，则是一个值得讨论的话题。从上面的推导中，我们发现分摊时间复杂度的系数为$q / (q-1)$，它会随$q$的增加而降低；另一方面，平均装填因子也会随$q$的增加而降低。因此，选择更大的$q$，事实上是以时间换空间的做法。

因为分摊$O(1)$已经很快，所以通常选取的$q$比较小。常见的公比选择有2和$3/2$。GCC、Clang和@邓俊辉2013数据结构 选择的公比是2；而MSVC则采用更节约空间的$3/2$。

需要指出的是，等比扩容也存在一些劣势：容量越大，装填因子不高带来的空间浪费愈发明显，所以有些对空间要求较高的情况下，也采用二者相结合的方式：在容量比较小时等比扩容、在容量比较大的时候等差扩容。这种思想在《网络原理》里的_慢启动_中得到了应用。

// TODO: 习题：等比缩容问题
// TODO: 习题：分摊复杂度分析的例子

== 插入、查找和删除 <vec:insert-remove-find>

对于任何数据结构，都有三种基本的操作：
+ *插入*（insert）：向数据结构中插入一个元素。
+ *查找*（find）：查找一个元素在数据结构中的位置。
+ *删除*（delete）：从数据结构中移除一个元素。

#h(2em)
在这一节中，我们以向量为例介绍这三种基本的操作。

=== 插入一个元素 <vec:insert>

要将待插入的元素`e`插入到`V[r]`，那么可以将原来的向量`V[0:n]`分成`V[0:r]`和`V[r:n]`两部分。
- 插入之前，向量是`V[0:r]`，`V[r:n]`。
- 插入之后，向量是`V[0:r]`，`e`，`V[r:n]`。
#h(2em)可以发现，在插入的前后，前一段`V[0:r]`的位置是不变的，而后一段`V[r:n]`需要整体向后移动1个单元的位置。据此，可以设计下面的算法，算法的原理如@fig:vec5 所示。

#figure(
    image("images/vec5.svg", width: 40%),
    caption: "往向量里插入一个元素",
) <fig:vec5>

```cpp
iterator insert(iterator p, const T& e) override {
    if (m_size == m_capacity) {
        reserve(m_allocator(m_capacity, m_size));
    }
    std::move_backward(p, end(), end() + 1);
    *p = e;
    ++m_size;
    return p;
}
```

#graybox[【C++学习】#linebreak()#h(2em)
为了让我们在 @vec:capacity-size:expand-strategy 定义的扩容策略被嵌入到向量里来，我们可以为向量模板增加一个参数，写成下面这样的形式。
```cpp
template <typename T, typename A = VectorAllocatorGP<std::ratio<3, 2>>
    requires std::is_base_of_v<VectorAllocator, A>
class Vector : public AbstractVector<T> { /* ... */ };
```
#h(2em)
在上面这个模板参数表声明中，我们规定模板的第二个参数`A`必须是我们上面实现的`VectorAllocator`的派生类。用户可以不显式地指定扩容策略，而选择我们默认的策略（公比为$3 / 2$的等比扩容）；也可以使用自定义的扩容策略。加入这个参数之后，我们只需要在`insert`的开头进行一次判断，就可以自动地在插入满向量时进行扩容。
]

=== 平均复杂度分析 <vec:average-analysis>
为了更定量地分析插入操作的时间效率，引入一个新的复杂度分析策略：*平均复杂度*。

在介绍复杂度时曾经强调，复杂度是依赖于数据_规模_，不依赖于输入_情况_的分析手段。在上面的插入算法中，数据规模通常认为是$n$，而$r$是具体情况带来的参数。为了研究不同具体情况对算法时间效率的影响，有三种常见的分析手段：
+ *最坏时间复杂度*：研究在情况最坏的情况下的复杂度。很多算法有硬性的时间限制（如在算法比赛中，通常要求输出结果的时间不能多于1s或2s），此时常常使用最坏时间复杂度分析。这是最常用的时间复杂度分析。
+ *最好时间复杂度*：研究在情况最好的情况下的复杂度。研究最好时间复杂度的意义远小于最坏时间复杂度。最好时间复杂度有时用于嘲讽某种算法的效率：在最好的情况下，这种算法的复杂度也只能达到（某个复杂度），而我的新算法在最坏的情况下也可以达到（某个更好的复杂度）。
+ *平均时间复杂度*：研究在平均情况下的复杂度。如果没有硬性的时间限制，则平均时间复杂度往往能更好地反映一个算法的总体时间效率。平均时间复杂度需要知道每种情况发生的_先验_概率，在这个概率的基础上计算$T(n)$的_数学期望_的复杂度。在针对现实数据的实验研究中，常见的假设包括正态分布、帕累托（Pareto）分布和泊松（Poisson）分布；而在《数据结构》学科中，通常假设成_等可能的分布_，以方便进行理论计算。就分摊时间复杂度一样，平均时间复杂度的计算也经常是非常复杂且困难的，只需要了解其基本的技术即可。

#h(2em)平均复杂度很容易和分摊复杂度发生混淆，需要加以区分。下面是它们的一些典型的差异：
+ 分摊复杂度是_一系列_连续操作的_平均_效率，而平均复杂度是_单次_操作的_期望_效率。
+ 分摊复杂度的一系列连续操作是有可能（通常都）存在后效的，而平均复杂度只讨论单次操作的可能情况。
+ 分摊复杂度需要指定每次进行何种的_基本操作_，而平均复杂度需要指定各种情况的_先验概率_。
+ 分摊时间复杂度依赖于一系列连续操作，但不同的操作序列可能导致不同的分摊复杂度。因此，分摊时间复杂度可以叠加“最坏”、“最好”和“平均”的修饰词，而平均时间复杂度是和最坏、最好并列且互斥的。

#h(2em)
最坏、最好、平均时间复杂度对应统计里的_最大值_、_最小值_和_数学期望_。显然，其他统计量，比如_方差_，在分析的时候也是有价值的，也深得科研人员重视，但它超出了本书和一般计算机工程师需要掌握的范围。

现在回到插入的算法，它的时间复杂度是$Theta(n-r)$（不考虑扩容）。显然，最好时间复杂度是$O(1)$（插入在末尾的情况），最坏时间复杂度是$Theta(n)$（插入在开头的情况）。这里有略微不严谨的地方，因为`r`的最大值可以取到`n`，此时`n-r=0`，不再符合复杂度记号的定义；不过，因为我们清楚任何算法的时间都不可能为0，所以一般不在这个细节上做区分。

为了求平均时间复杂度，一个合理的假设是，`r`的取值对于`[0:n+1]`之间的整数是等概率的（注意有`n`个可以插入的位置，而不是`n-1`个）。在这个假设下，容易算出单次插入的平均时间复杂度为$Theta(n)$。

=== 查找一个元素 <vec:find>
查找需要返回被查找元素所在的位置。和插入、删除相比，查找具有更加丰富的灵活性，甚至于一些编程语言（如SQL）的核心就是查找。

最简单的查找是_按值查找_。即，给定被查找元素的值，在数据结构中找到等于这个值的元素所在的位置。对于更加复杂的查找类型，比如_按区间查找_（给定被查找元素所在区间）等，人们设计了更加复杂的数据结构来应对。对于按值查找的问题，最简单的方案就是检测向量中的每个元素是否等于要查找的元素`e`，如果等于，就把它的秩返回。

```cpp
iterator find(const T& e) const override {
    for (auto it { begin() }; it != end(); ++it) {
        if (*it == e) {
            return it;
        }
    }
    return end();
}
```

#graybox[【C++学习】#linebreak()#h(2em)
关于找不到的情况，有多种处理方式。上面采用的方法是返回无效迭代器，除了返回序列尾部溢出的`end()`之外，返回序列头部溢出的`--begin()`也是常见的选择。此外，也可以将返回值的类型改为`std::optional<iterator>`，当找不到的时候返回一个无效值。
]

设`e`在向量中的秩为`r`，那么在_查找成功_的情况下，上述算法的时间复杂度为$Theta(r)$。在_查找失败_的情况下，算法的时间复杂度为$Theta(n)$。这里可以分析，在等可能条件下，查找成功时的平均时间复杂度是$Theta(n)$。
注意，查找成功的概率是一个很难假设的值，所以在分析平均时间复杂度时，通常只分析“查找成功时”和“查找失败时”的平均时间复杂度，而不会将它们混为一谈。

因为对于向量`V`和待查找元素`e`的情况没有更多的先验信息，所以暂时也没有比上面更高效的解决方案。*利用信息思考*是计算机领域重要的思维方式。在设计算法时，应尽可能利用更多的先验信息。反之，如果先验信息不足，则算法的效率受到信息论限制，不可能会特别高。这个思维方式在后文介绍各种算法的设计过程时，还会反复出现。

=== 删除一个元素 <vec:remove>
删除元素是插入元素的逆操作。在插入元素时，让被插入元素的后继_后移_；因此在删除元素的时候，只需要让被删除元素的后继_前移_即可。需要注意前移和后移在方向上的差别，插入时的`std::move_backward`，逆操作应该是`std::move`。

```cpp
iterator erase(iterator p) override {
    std::move(p + 1, end(), p);
    --m_size;
    return p;
}
```

#h(2em)
和插入一样，可以分析出删除操作时间复杂度$Theta(n-r)$，平均时间复杂度$Theta(n)$，空间复杂度$O(1)$。到此为止，我们实现了完整的`Vector`类，可以开始实验了。如果您自己完成了向量的设计，可以使用#bluetxt[`VectorTest.cpp`]进行简单的功能测试，并在实验中将`dslab::Vector`替换为自己的向量类。

=== 插入连续的元素 <vec:insert-continuous>

#bluetxt[实验`VectorInsert.cpp`。]在这个实验中，我们将用实验观察等差扩容和等比扩容的时间效率差异。因为评估的是分摊时间，所以需要构造一个插入连续元素的场景来进行观察。从@vec:insert 中我们知道，在位置`r`插入一个元素的时间复杂度为$Theta(n-r)$。为了降低插入连续元素这个操作本身对实验结果的影响，更好地观察扩容时间，我们固定每次都在向量的末尾插入元素。

我们构造下面的类，作为插入连续元素问题的基类。因为在测试过程中，每次连续插入结束之后，需要将向量重置为空（避免已分配的空间影响），所以这里定义了一个`reset`方法。

== 本章习题

在 @vec:capacity-size 中：#linebreak()
+ #medium 假设我们预先分配了大小为$N$的内存空间给`m_data`，并且不允许重新申请内存空间，那么此时向量的扩容上限为$N$。在这种场景下应该如何设计`reserve`函数进行扩容？
+ #hard 假设我们预先分配了大小为$N$的内存空间作为内存池，在扩容的时候，`m_data`不从操作系统申请新的内存，而是从内存池中未被占用的空间里申请新的内存。开始时，`m_data`指向内存池的起始地址，`m_capacity`为0，随着向量的规模增大不断扩容。在这个场景下讨论等比扩容$q$的选择问题。
+ #medium 自动扩容可以在装填因子达到1并且还需要增加规模时进行；自动缩容则应该在装填因子小于某个阈值$theta$的情况下进行。采用分摊分析的方法，分析等差缩容和等比缩容的时间复杂度。
+ #hard 同时采用公比为$q_1$的等比扩容和公比为$q_2$的等比缩容，分析这种策略的_最坏_分摊时间复杂度。

#h(2em)在 @vec:insert 中：#linebreak()
+ #easy 为什么插入中采用了`std::move_backward`，而删除中采用了`std::move`？
+ #medium 在示例代码中使用了 @vec:capacity-size:expand-strategy 中定义的扩容策略来实施扩容，那么扩容的时候，需要先申请一片内存，将原来的数据复制到新的内存中；随后再将`V[r:n]`向后移动1个单位。因此在示例代码中，`V[r:n]`被移动了两次。请设计一个插入时的自动扩容方法，使得`V[r:n]`只需要移动一次。

#h(2em) 在 @vec:average-analysis 中：#linebreak()
+ #medium 如果分摊分析中的一系列操作都是无后效的，那么分摊复杂度是否和平均复杂度相同？
+ #easy 对一个等比（$q=2$）扩容的空向量连续插入一系列元素，每次被插入的元素插入在每个位置是等可能的，在此条件下计算插入的最坏、最好和平均分摊时间复杂度。
+ #hard 对一个等比（$q=2$）扩容的空向量连续插入一系列元素，每次被插入的元素必定插入在上一次插入位置的前面或后面（前面的概率为$p$，后面的概率为$q$，$p+q=1$），在此条件下计算插入的平均分摊时间复杂度。

#h(2em) 在 @vec:find 中：#linebreak()
+ #easy 如果向量中存在多个等于`e`的元素，那么示例代码中会返回第一个等于`e`的元素的位置。请设计一个查找方法，返回最后一个等于`e`的元素的位置。并分析该算法的时间复杂度。
+ #easy 网络流量通常满足Zipf分布。当使用向量存储路由表时，如果将热门站点放在路由表的前面，就可以加速路由查找。假设`e`在向量中的位置服从Zipf分布，即$f(x) = x^(-alpha ) / ( sum_(k=1)^n k^(-alpha) )$，讨论查找成功时的平均时间复杂度。