#import "template.typ": *

= 列表 <lis:chapter>

本章介绍另一种线性表：*列表*（list）。列表和向量的区别在于，列表不要求在内存中占据的空间是连续的。这一特点赋予了列表更大的灵活性，使列表的一些操作比向量效率更高；但同时，这一特点也让列表无法通过秩定位到内存地址，丧失了循秩访问的能力，从而在另一些操作上效率不如向量。本章将详细介绍列表的特质，请读者在阅读的同时和向量进行对比，以便更好地理解列表的特点。

== 列表的结构 <lis:structure>

列表不要求在内存中占据的空间是连续的，因此不能循秩访问，只能循位置访问：通过指向列表中某个元素的指针（也就是该元素的地址）来访问它。那么，如何获得一个元素的地址呢？首先，把所有元素的地址汇总在一张表看起来是可行的，但如果这么做的话，这张表本身如何存储就变成了一个新的问题。如果这个表使用向量存储，那么我们就放弃了列表的不连续的灵活性；如果这个表使用列表存储，那么就成为了一个嵌套的问题。所以，我们不能把所有元素的地址汇总在一张表，也就是说，我们不能采用_集中式_的地址存储，需要采用_分布式_的地址存储。

所谓分布式的地址存储，就是我们在每个元素处，同时存储它前一个和后一个元素的地址。这样，我们无论是从前往后还是从后往前，都能遍历整个列表。很明显，这样带来了一个坏处，就是我们只能“逐个”访问元素，而不能像向量那样根据任意的秩访问元素。这就是列表选择更大灵活性的代价。除此之外，列表还有一些其他的代价，比如每个元素处除了它本身的空间，还需要存两个地址，因而有可能需要付出比向量更大的空间（注意这里是有可能，因为向量的装填因子很低时，所造成的的空间浪费更大）。为了降低列表的空间浪费，有时我们会放弃存储前一个元素的地址，只存储后一个元素的地址。这种情况称为*单向列表*（forward list）或单链表，相对应地，同时存储前一个和后一个元素地址的情况称为*双向列表*（bidirectional list）或双链表。本书中如无特别说明，列表均指双向列表。

=== 单向列表的节点 <lis:forward-node>

为了设计列表的抽象类，我们需要首先将列表中的每个元素抽象出来。列表中每个数据元素及其附加属性（即，前后元素的地址）组成了一个数据单元，或者称*节点*（node）。《计算机科学技术名词》@科学技术名词 认为“节点”是数据结构中数据元素的连接点或端点，而“结点”是计算机网络中的网络拓扑设备，并注明二者互为别称。本书不做区分。本着从简到繁的精神，我们从单向列表的节点开始。

```cpp
template <typename T>
class ForwardListNode {
    T m_data;
    std::unique_ptr<ForwardListNode<T>> m_next {};
};
```

#graybox[【C++学习】#linebreak()#h(2em)
在列表中，每个节点只有唯一的直接前驱，因此可以用唯一控制所有权的智能指针`std::unique_ptr`来存储。一个节点的所有权归属于它的直接前驱，第一个节点的所有权归属于列表对象。和裸指针或`std::shared_ptr`相比，这样做可以做到列表作为线性结构的排他性，即不会出现形如$a arrow.r b arrow.l c$这样，两个节点指向同一个节点的列表结构。一个极端的例子是，如果采用裸指针，列表甚至有可能形成$a arrow.r b arrow.r c arrow.r d arrow.r b$这种形式。在这个例子中，因为$b arrow.r c arrow.r d arrow.r b$形成了一个环，所以会导致在列表上的访问无限循环。

使用智能指针`std::unique_ptr`来持有下一个节点的所有权时，由于下一个节点又持有了再下一个节点的所有权，所以以此类推，一个节点实际上持有了其所有后继节点的所有权。根据智能指针的特性，一个节点被释放时，它所持有的下一个节点也会被释放，以此类推，它所有后继节点都会被释放。那么，只要释放一个列表的第一个节点，整个列表就会被递归地释放。
]

递归释放（即析构函数声明为`default`）这个想法看起来很美好，实际上却会出现问题。


#figure(
    image("images/lis8.svg", width: 100%),
    caption: "列表节点的递归析构和迭代析构",
) <fig:lis8>

如果我们清空一个规模为`n`的列表`L`，则如 @fig:lis8 中的左图所示，黄色节点代表析构中的节点，可以看出在最后一个节点被析构的时候，前面所有的节点都在等待。因此，会触发`n`层析构函数的递归，当`n`非常大时，会引发栈溢出（stack overflow）错误。因此，我们需要手动设计列表节点的析构函数，将析构函数的递归改为迭代，而不能依赖于`std::unique_ptr`的自动释放空间。下面展示了一个迭代版本的析构函数，如@fig:lis8 的右图所示，它不会造成大量节点在析构中状态等待的情况。

```cpp
virtual ~ForwardListNode() {
    auto p { std::move(m_next) };
    while (p != nullptr) {
        p = std::move(p->m_next);
    }
}
```

#graybox[【C++学习】#linebreak()#h(2em)
另一方面，对列表节点进行复制或者移动操作是没有意义的。首先，如果复制一个列表节点，那么就需要面临，复制出的列表节点和原节点的后继是否指向同一个节点的问题。然而因为`std::unique_ptr`的独占性，指向同一个节点是不可能的，而如果递归地复制所有后继，那么这样的操作等同于复制_列表_而不是复制_列表的节点_。其次，如果移动一个列表节点，似乎原节点的后继的所有权可以被移交给新的节点，然而，原节点的前驱并不知道这个移动操作，它持有的仍然是移动前的节点的所有权，从而造成列表被切断（断链）。退一步说，即使我们通过某种方式，让一个新节点替换了原节点在其所在列表中的位置，这样做的意义也不大，因为完全可以直接移动_数据_字段`m_data`，不需要移动节点。

从上面的分析可以看出，我们不需要为列表节点提供复制和移动操作。因此，我们可以将复制和移动操作声明为删除函数，以防止用户误操作。基于 @vec:capacity-size:init 所介绍的“5原则”，我们需要声明以下5个函数（默认构造函数不再可以省略）。

```cpp
ForwardListNode() = default;
ForwardListNode(const ForwardListNode&) = delete;
ForwardListNode& operator=(const ForwardListNode&) = delete;
ForwardListNode(ForwardListNode&&) = delete;
ForwardListNode& operator=(ForwardListNode&&) = delete;
```
]

=== 双向列表的节点 <lis:bidirectional-node>
#v(-1em)
#graybox[【C++学习】#linebreak()#h(2em)
当我们试图扩展单向列表到双向列表的时候，我们有两种选择。
+ 让前向指针和后向指针共享节点的所有权，也就是两个指针都声明为`std::shared_ptr`。这种做法过于浪费空间，因为`std::shared_ptr`除了指针本身之外，还包括一个引用计数。
+ 仍然保留单向列表中，只有后向指针拥有节点的所有权的设计，即后向指针仍然是`std::unique_ptr`，而前向指针则使用不涉及所有权的裸指针。这种做法节约了空间，但会破坏前向指针和后向指针的对称性，提高算法设计难度。]

#graybox[
#h(2em)在本书中，采用后向指针单独拥有所有权，而前向指针使用裸指针的设计，因为对于基础数据结构而言，增加两个引用计数的成本是难以接受的。需要注意的是，前向指针的裸指针永远不会被释放。作为一个良好的编程习惯，应当避免在使用智能指针的工程中使用`new`或者`delete`关键字操作裸指针，应当始终注意裸指针是一个表示无所有权的指针。

当然，即使用户保证自己不会操作裸指针，这种做法仍然是存在安全隐患的。用户可能将裸指针传递给了其他对象，随后通过智能指针将节点释放。这样，裸指针就变成了悬空指针，并且没有办法检测到。因此，我们应当在接口上尽可能使用迭代器操作列表，将裸指针操作封装在类内部，避免用户将裸指针传递给外部的其他对象。
]

```cpp
template <typename T>
class ListNode {
    T m_data;
    ListNode<T>* m_prev {};
    std::unique_ptr<ListNode<T>> m_next {};
};
```

#linebreak()#v(-1.5em)

=== 哨兵节点 <lis:sentinel-node>

在单向列表中，我们只能从前向后访问节点，所以，我们只需要知道指向第一个节点的指针，就可以从前向后依次访问所有节点。而在双向列表中，我们可以从两个方向访问节点，因此我们需要知道指向第一个节点和最后一个节点的指针，才可以从两个方向依次访问所有节点。

在 @邓俊辉2013数据结构 中，每个列表存在两个不存储实际数据的虚拟节点，称为*头哨兵节点*和*尾哨兵节点*，或者简称为*头节点*（head）和*尾节点*（tail），用来标志列表的开始和结束。即使列表是空列表，这两个节点也存在。哨兵节点的引入使得许多实现得到了简化（simplify）和统一化（unify），比如前插（在一个节点之前插入新元素）不需要对第一节点进行特殊判定。在 @严蔚敏1997数据结构 中介绍的列表则是没有哨兵节点的，转而使用指向第一个节点和最后一个节点的裸指针来对头尾进行定位，称为*头指针*和*尾指针*。这不会影响到列表的功能，节约了2个节点的空间，但有些功能的实现会略显复杂。本章采用 @邓俊辉2013数据结构 的设计，使用哨兵节点。

```cpp
template <typename T>
class AbstractList : public LinearList<T, /* iterators */> {
protected:
    virtual ListNode<T>* head() = 0;
    virtual ListNode<T>* tail() = 0;
public:
    virtual iterator insertAsNext(iterator p, const T& e) = 0;
    virtual iterator insertAsPrev(iterator p, const T& e) = 0;
};
```

#h(2em)在列表类中，我们将插入操作区分为了前插（插入为`p`的直接前驱）和后插（插入为`p`的直接后继）。因为后向指针和前向指针不是对称的，所以前插和后插也有一些区别。#linebreak()
#graybox[【C++学习】#linebreak()#h(2em)
单向列表的抽象类是相似的。注意，在基类`LinearList`中存在一些方法是单向列表无法实现的，比如，我们使用下面的方法来实现`back`（取最后一个元素）：
```cpp
virtual T& back() { return *--end(); }
```
#h(2em)由于单向列表节点中没有储存指向直接前驱的指针，单向列表的迭代器是无法实现`--`操作的。因此，我们无法实现上述的`back`方法。对这样的问题，有两种处理模式：
+ 重写`back`方法，让单向列表中第一个元素开始遍历，直到最后一个元素。这样的实现会使得`back`方法的时间复杂度变为$Theta(n)$，而不是$O(1)$。但是，用户并不一定能够敏锐地发现这个问题，用户可能仍然以为这个方法是$O(1)$的。一旦这样自以为是的用户在自己的程序中大量使用了`back`方法，其程序的性能将会受到严重影响。这一问题是有先例的，在C++11强制规定前，STL的`std::list::size()`就是$Theta(n)$的，而许多用户并不知情，导致他们的程序有很大一部分时间被浪费在了无意义的遍历求列表规模上。
+ 隐藏`back`方法。通过将`back`方法重载为一个`private`方法，防止用户调用。这样，用户在使用`back`方法时，会得到一个编译错误，从而引起他们的注意。如果用户真的想要获取最后一个元素，他们可以通过`*(begin() + (size() - 1))`等方式进行。这样的实现虽然不够优雅，但是可以避免用户的误用。

#h(2em)本书的示例代码采用了隐藏的处理方式。由于`back`方法会返回一个`T&`，而我们不希望使用这个方法，它没有有意义的返回值，所以可以用下面的方式抛出一个异常而不返回值：
```cpp
[[noreturn]] T& back() override {
    throw std::logic_error("/* error message */");
}
```
]

#figure(
    image("images/lis1.svg", width: 80%),
    caption: "单向列表和双向列表",
) <fig:lis1>

如@fig:lis1 所示，我们在单向列表和双向列表的两头各添加一个哨兵节点，代表所有权的智能指针用实线箭头表示，不涉及所有权的裸指针则用虚线箭头表示。由于哨兵节点的存在，用户总是可以知道列表的头和尾的位置。因此，即使在单向列表中，用户无法直接获得尾部（`back`）元素中的数据（需要从头节点向后依次遍历来寻找尾部），也无法直接删除尾部（`pop_back`）的元素，但用户可以直接在尾部之后插入（`push_back`）。如果没有尾节点的存在，则我们无法直接进行`push_back`操作。#linebreak()
#graybox[【C++学习】#linebreak()
#h(2em)在C++的标准库中，`std::forward_list`就是这样设计的：它包含一个最简单、最节约空间的抽象，没有尾节点也不支持`push_back`。]


需要特别指出，哨兵节点仅仅用于列表的实现方法，而非列表的组成部分，因此在@fig:lis1 我们将它们用灰色表示。当我们具体讨论到某个列表`L[0]`$arrow.r$`L[1]`$arrow.r dots arrow.r$`L[n-1]`的时候，第一个节点`L[0]`和最后一个节点`L[n-1]`都是实际存储元素的节点，而非头节点或尾节点。在列表中，`L[0]`_没有前驱_；而在列表的具体实现中，我们_可以认为_头节点是它的直接前驱以方便设计代码。

== 插入、查找和删除 <lis:insert-find-remove>

=== 后插一个元素 <lis:insert-as-next>

我们首先讨论后插。给定被插节点的位置`p`和待插入元素`e`，将元素`e`插入到列表中，使其对应的节点成为`p`的直接后继，这种类型的插入称为后插。假设`p`原有的直接后继是`q`，则二者的指针连接形成$p arrow.r q$的形式。我们希望将`e`插入到二者之间，形成$p arrow.r e arrow.r q$的形式。这里可以看出引入哨兵的好处。在引入哨兵节点之后，对于任何一个被插节点，它总是有直接后继`q`；当被插节点是最后一个节点时，`q`就是尾哨兵节点，而不需要进行特判。

从宏观层面上来说，对于双向列表，我们需要对`p`的后向指针、`q`的前向指针以及新生成的`e`的双向指针进行赋值，然而，这四个指针的赋值顺序需要仔细斟酌。这是设计列表算法的易错点，因为“拆散-重组”的过程不是一次性发生的，必定存在先后顺序。允许的顺序有许多种，但如果顺序错误，就有可能在拆散的过程中丢失了信息，导致无法进行重组。在设计完列表节点算法之后，应当检查“拆散-重组”过程是否有遗漏，是否有重复，是否有错误。

比如说，如果我们直接断开`p`到`q`的后向指针，将`e`接入，形成$p arrow.r e | q$的形式，那么`q`会因为失去所有权而被智能指针自动回收（这种情况可以被生动地形容为“断链”）。因此，我们可以通过`std::swap`交换智能指针的所有权，然后再将`q`连接到`e`的后向指针处。建立好$p arrow.r e arrow.r q$之后，再将前向指针补上。

```cpp
iterator insertAsNext(iterator p, const T& e) override {
    auto node { std::make_unique<ListNode<T>>(e) };
    auto& q { p.node()->next() };
    std::swap(q, node);
    q->next() = std::move(node);
    q->prev() = p.node();
    q->next()->prev() = q.get();
    ++m_size;
    return ++p;
}
```

#figure(
    image("images/lis2.svg", width: 80%),
    caption: "双向列表的后插",
) <fig:lis2>

因为使用了交换语义，上面的这种做法产生了比预期更多的赋值次数。我们看到在上面的算法中，对于`node`的重复赋值是_不到位工作_，它经历了`e`变化为`q`、再变化为空的过程，而实际上可以让它一步到位地变化为空。于是，我们不应该从$p arrow.r e | q$开始，可以从另一个后向指针，也就是$p | e arrow.r q$开始。这样就能减少一次赋值。

从@fig:lis2 中可以看出，在后插的过程中，应当首先让`e`的后向指针接管`q`的所有权；而其他三项的赋值次序是可以随意的。当然，尽管次序可以随意，但在书写的时候仍然需要当心。比如，在`e`的后向指针接管`q`的所有权之后，我们不再能通过`p`的后向指针来找到`q`，只能通过`e`的后向指针来找到它。这些细小的注意点有时熟练的程序员也会忽略，因此借助图形和手工演算进行检查是有意义的。

```cpp
iterator insertAsNext(iterator p, const T& e) override {
    auto node { std::make_unique<ListNode<T>>(e) };
    node->next() = std::move(p.node()->next());
    node->next()->prev() = node.get();
    node->prev() = p.node();
    p->next() = std::move(node);
    ++m_size;
    return ++p;
}
```

#h(2em)单向列表的情况大同小异，只是减少了对前向指针赋值的操作。可以看出，在列表上做后插的时间复杂度和空间复杂度均为为$O(1)$。

=== 前插一个元素 <lis:insert-as-prev>

对于双向节点，前插的过程和后插大同小异。因为头哨兵节点的存在，我们总是可以找到`p`的直接前驱`q`，于是我们只需要在$q arrow.r p$之间插入`e`，和前面的$p arrow.r q$只有字母上的区别。当然，也可以直接用后插实现前插。

```cpp
iterator insertAsPrev(iterator p, const T& e) override {
    return insertAsNext(--p, e);
}
```

#h(2em)对于单向列表，情况变得有些令人沮丧。因为单向列表中，我们无法使用前向指针，也就无法定位到`p`的直接前驱。那么，我们是否无法进行前插呢？是，也不是。我们可以用两种方法实现前插：
+ 从头节点开始，沿着后向指针访问整个列表，寻找`p`的直接前驱，然后再采用和上面一样的方式进行前插。显而易见，如果`p`在列表中的秩是`r`，则该方法的时间复杂度高达线性的$Theta(r)$。我们放弃循秩访问而使用列表，为的是允许操作不连续内存，从而在插入和删除的时候达到$O(1)$的常数复杂度；因此，这种方法虽然万无一失，但和我们的初衷背道而驰。此外如@lis:sentinel-node 中所述，对外接口的时间复杂度也会带来隐患。
+ 使用后插代替前插。我们首先找到`p`的直接后继`q`进行一次后插，形成$p arrow.r e arrow.r q$的形式，然后我们_交换_`p`和`e`节点的值，形成$e arrow.r p arrow.r q$，如@fig:lis3 所示。这样在_值_上实现了前插，但是在_位置_上并没有实现前插。比如，如果原先外部有一个迭代器指向`p`，我们执行前插之后，这个迭代器并不知道`p`已经被`e`“偷梁换柱”了，它可能还以为自己指向的是`p`，从而产生不可估计的错误。因此，这种方法事实上损失了安全性。但是，毕竟它是一个$O(1)$的方法，我们也只能接受它，并期待用户正确地使用这个方法。

#figure(
    image("images/lis3.svg", width: 80%),
    caption: "单向列表的前插",
) <fig:lis3>

#graybox[【C++学习】#linebreak()#h(2em)
    很显然，两种前插都存在一些问题，因此
`std::forward_list`就不允许进行前插。在现实中设计程序时，应当避免这种高风险的设计。
]

回到使用后插代替前插的技术上。和@lis:insert-as-next 一样，我们注意到采用交换语义会引入不到位的赋值。在消除交换语义之后，一个可能的实现如下。

```cpp
iterator insertAsPrev(iterator p, const T& e) override {
    auto node { std::make_unique<ForwardListNode<T>>(std::move(*p)) };
    *p = e;
    node->next() = std::move(p.node()->next());
    if (p == end()) {
        m_tail = node.get();
    }
    p.node()->next() = std::move(node);
    ++m_size;
    return p;
}
```

#h(2em)前面讨论过，如果原先外部有一个指针指向`p`，我们执行前插之后，这个指针并不知道`p`已经被替换了。我们无法保证用户使用的“外部指针”的安全性，但我们需要保证数据结构内部的指针的安全性。这个可能丧失安全性的指针就是尾节点指针`m_tail`当我们要在尾节点处进行前插（也就是`push_back`）的时候，上述方法事实上进行了后插，并将原先的尾节点赋值为`e`。在这种情况下，我们需要将尾节点指针指向新的尾节点处。

另外，请注意这里必须对`p`中的数据使用移动语义，而不能使用复制语义，否则当`p`中的数据非常大（比如，一个被嵌套在列表里的向量）时，会引入大量的（非常数的）性能损失。

=== 查找一个元素 <lis:find>

无论是单向列表还是双向列表，查找元素的过程和无序向量都是一样的，只需要从前向后一个一个查找即可。因为不支持循秩访问的缘故，即使是有序列表，也不支持折半查找。下面是一个示例的实现。

```cpp
iterator find(const T& e) const override {
    auto p { begin() };
    while (p != end() && *p != e) {
        ++p;
    }
    return p;
}
```

#linebreak()#v(-1.5em)
=== 删除一个元素 <lis:remove>

列表删除是插入的逆操作。对于双向列表，假设被删除的节点为`p`，由于头节点和尾节点的存在，我们可以保证它存在直接前驱`q`和直接后继`r`。因此，我们需要将$q arrow.r p arrow.r r$变形为$q arrow.r r$。显然，我们只需要对`q`的后向指针和`r`的前向指针各进行一次赋值。顺序仍然是重要的，但难度比插入降低了不少（因为2次赋值的顺序一共只有2种）。下面是一个可行的实现。

```cpp
iterator erase(iterator p) override {
    auto node { p.node() }, q { p + 1 };
    node->next()->prev() = node->prev();
    node->prev()->next() = std::move(node->next());
    --m_size;
    return q;
}
```

#h(2em)类似地，上面的做法也不适用于单向列表的删除。对于单向列表，我们需要采用和前插相似的技术，首先找到`p`的直接后继`r`，以及`r`的后继`s`。我们在$p arrow.r r arrow.r s$上交换`p`和`r`节点上的值，从而在_值_的角度，变成了$r arrow.r p arrow.r s$，然后重新赋值`r`的后向指针，变为$r arrow.r s$即可。双向列表和单向列表在删除节点上的区别如@fig:lis4 所示，请注意在双向列表的场合，当移交所有权之后，节点`p`会被智能指针自动释放（用灰色表示）。

#figure(
    image("images/lis4.svg", width: 80%),
    caption: "在列表中删除一个元素",
) <fig:lis4>

@fig:lis4 中，`s`是虚线节点，这是因为即使在存在尾节点的列表中，`s`仍然可能为空（`nullptr`）。如果`s`为空，那么`r`就是尾节点（在有哨兵的场合），交换元素之后我们会把原先的尾节点删除。所以，我们需要进行一次特判，在上述情况下让新的`r`成为新的尾节点。在消除了交换语义带来的不到位赋值之后，得到的一种示例程序如下所示。

```cpp
iterator erase(iterator p) override {
    auto q { p + 1 };
    *p = std::move(*q);
    p.node()->next() = std::move(q.node()->next());
    if (q == end()) {
        m_tail = p.node();
    }
    --m_size;
    return p;
}
```

#h(2em)和@lis:insert-as-prev 一样，这里的尾节点指针`m_tail`也是需要维护的“外部的指向节点的指针”。我们需要对这个指针重新赋值以避免安全性问题。#linebreak()
#graybox[【C++学习】#linebreak()#h(2em)
同样地，在STL的`std::forward_list`中，为了安全性考虑，只提供“删除后继”的方法`erase_after`而不提供直接删除的方法。]

从上面对插入、查找和删除的分析中可以看出，列表的三种基本操作完全不涉及规模。所以，如果不需要在$O(1)$时间里获取规模，那么列表是可以不记录这个属性的。不记录规模可以使列表在插入和删除时减少一次赋值，从而略微提高列表的性能。至此，列表的基本操作已经讨论完毕，可以在#bluetxt[`list.cpp`]和#bluetxt[`flist.cpp`]中分别对双向列表和单向列表进行测试。

=== 在头部和尾部连续插入元素 <lis:head-tail-insert>

#bluetxt[实验`lins.cpp`。]随着三种基本操作分析完毕，我们可以开始对列表展开实验。这一节讨论在列表的头部和尾部连续插入元素的情况。

在示例代码中，采用示例实现的向量、双向列表和单向列表类作为实验对象。我们考虑两种环境。第一种是连续在头部插入元素，也就是每次插入的元素会成为线性表的第一个元素；另一种是连续在尾部插入元素，也就是每次插入的元素会成为线性表的最后一个元素。

这个实验表明，当在尾部连续插入元素时，向量的效率显著高于列表，但是单向列表并没有和双向列表之间有很大的差异。根据您的运行环境不同，向量和列表大致呈现一个数倍的性能差距，总体来说是常数的。需要特别指出的是，尽管在尾部_连续_插入元素的测试中向量的性能高于列表，但对于_单次_插入元素的过程则不一定。触发扩容时，向量单次插入元素的时间复杂度可达$Theta(n)$，而列表是稳定的$O(1)$。这一点是列表的独特优势，在对响应时间稳定性有要求的场合下，向量的扩容变得不能接受，而列表的插入时间是可以保证很低的。#linebreak()
#graybox[【C++学习】#linebreak()#h(2em)
当在头部插入元素时，可以显著地看到，向量$Theta(n^2)$的时间复杂度远高于列表$Theta(n)$的时间复杂度，当$n=10^6$的时候向量的情况已经难以接受；我们可以直接做一个判断，在这种情况下抛出一个异常拒绝执行，如下所示。

```cpp
if constexpr (std::is_base_of_v<Vector<std::size_t>, L<std::size_t>>) {
    if (n >= 1000'000) {
        throw std::runtime_error { "/* error message */" };
    }
}
```

#h(2em)因为向量的耗时增长很快，我们在$n=10^5$量级已经可以看出它的性能，因此不需要花费大量的时间等待它在更大的规模上完成实验。这里采用了C++17引入的`if constexpr`语法，从而实现在编译期判断。上面的代码对于以向量为参数的模板实例，会将`if constexpr`内的判断编译进去；而对于以列表为参数的模板实例，则不会将`if constexpr`内的判断编译进去；这个向量和列表的区分是编译期完成的，运行期不会再做判断。这一语法简洁清晰，可以用来替代C语言风格很容易被滥用的`#ifdef`等条件编译命令。
]

#figure(table(
    columns: 5,
    [插入位置], $n$, [向量], [双向列表], [单向列表],
    [尾部], [$10^4$], [0], [0], [0],
    [尾部], [$10^5$], [1], [2], [3],
    [尾部], [$10^6$], [9], [32], [27],
    [头部], [$10^4$], [26], [0], [0],
    [头部], [$10^5$], [2774], [2], [2],
    [头部], [$10^6$], [非常大], [31], [27],
),
    caption: "不同数据结构连续插入元素的耗时对比",
) <tab:lis1>

如@tab:lis1 所示，双向列表和单向列表在时间上的性能差异实际上非常小。双向列表虽然节点多了一个字段，但消耗的时间和单向列表相比，只有非常有限的增加，与此同时，它获得了从后向前访问的能力、更强的灵活性以及更好的安全性（关于安全性，在@lis:insert-as-prev 和@lis:remove 已经讨论过）。因此，除非性能要求苛刻或空间不足，否则都建议使用双向列表。

=== 顺序删除和随机删除 <lis:remove-order-random>

当我们连续地在列表中插入节点时，这些节点也会存在一定程度上的空间连续性，因为它们的空间是操作系统连续分配的。这会导致我们的实验并不能真实地反映出现实情况下的列表所包含的节点地址弱局部性这一特征。在这个实验中我们将会认识到，如果列表所包含的节点地址局部性很差，会对列表的性能造成很大的负面影响。

#bluetxt[实验`lrm.cpp`。]我们考虑下面的连续删除场景。

```cpp
template <typename T>
class ContinuousPop : public Algorithm<void()> {
protected:
    List<T> L;
    Vector<typename List<T>::iterator> V;
public:
    virtual void initialize(std::size_t n) = 0;
    void operator()() override {
        for (auto p : V) {
            L.erase(p);
        }
    }
};
```

#h(2em)在这个框架中，我们使用向量`V`来存储列表`L`的每一个节点的位置。通过改变初始化函数，我们让向量`V`成为顺序的或者随机的，然后，按照向量`V`中存储的节点次序依次删除列表中的元素。对于顺序存储的情况，每次向`L`加入元素后储存在`V`中即可。对于随机存储的情况，可以在顺序存储之后增加一个`std::shuffle`（见@vec:shuffle ）。

#figure(table(
    columns: 3,
    $n$, [顺序删除], [随机删除],
    [$10^5$], [2], [5],
    [$10^6$], [22], [96],
    [$10^7$], [246], [1561],
),
    caption: "顺序删除和随机删除的耗时对比",
) <tab:lis2>

如@tab:lis2 所示，从这个例子中可以看到，当`n`比较小的时候，顺序删除和随机删除的性能基本一致；但当`n`比较大的时候，二者就会产生一个明显的差异。这个性能差异就是随机删除的局部性丧失引起的。

在现实中，我们生成的列表可能不是以连续插入的形式分配内存的。因此，它可能天然就具有一个很差的局部性。这就意味着，现实中的列表在较坏的情况下有可能会更接近于本实验中随机访问的性能。结合@lis:head-tail-insert 的实验结果，我们意识到，列表和向量之间有着巨大的性能差距，甚至在数据结构规模较小的情况下，列表$O(1)$插入、删除的优势体现不出来，从时间消耗的角度上来说还不如$Theta(n)$的向量操作。因此对于小型线性表，无论我们是否需要循秩访问、折半查找等向量特性，都应该优先使用向量而不是列表。

=== 倒置列表 <lis:reverse>

当在向量上设计算法的时候，由于向量循秩访问的特性，我们可以对秩进行运算，从而快速、精准地找到某个元素。一个典型的例子就是折半查找。循秩访问使得向量中的元素地位比较“平等”；而在列表的场合，循位置访问使得列表中的元素地位比较“不平等”，比较“任人唯亲”。比如，从头节点出发访问列表中的一个元素时，所需要消耗的时间会和被访问元素的位置相关；越接近头部的元素，访问需要的时间越短。

我们可以站在更高的层次，理解
列表只能直接访问首尾两端、以及循位置访问“任人唯亲”的特性：列表是*线性递归定义*的。具体来说，列表可以被这样定义：
+ $emptyset$是列表（空列表，没有元素）。
+ 设`x`是一个节点，`L`是一个列表，则`x`$arrow.r$`L`是列表（`x`的后向指针指向`L`的第一个节点）。

#h(2em)这个定义具有和@sum:correctness 所述递降法相似的形式，并且它意味着列表适合使用*减治*思想设计算法。首先，我们研究递归边界（空列表）的情况；其次，对于规模为`n`的列表，我们将第一个节点提取出来，递归地研究后`n-1`个节点组成的子列表，再和第一个节点进行合并。对称地，我们可以想到列表具有另一个定义：
+ $emptyset$是列表。
+ 设`x`是一个节点，`L`是一个列表，则`L`$arrow.r$`x`是列表。

#h(2em)这一定义同样可以引出一种减治算法的设计。它和前一种定义的区别在于，平凡项`x`在减治项`L`的头部还是尾部。对于双向列表来说，头部减治和尾部减治是等价的，提取出平凡项`x`都只需要$O(1)$的时间。当然，我们需要注意，减治递归算法应用在列表上时，递归深度高达$Theta(n)$，这不但导致了较高的空间复杂度，同时在`n`较大时很可能引发栈溢出错误；因此在设计完成减治算法之后，应当尽可能将其修改为迭代算法。

单向列表的头部和尾部不具有对称性，因此情况会有所不同。考虑单向列表`L[0]`$arrow.r$`L[1]`$arrow.r$`L[2]`$arrow.r ... arrow.r$`L[n-1]`。当在头部进行减治时，只需要$O(1)$的时间就可以找到`L[0]`；而在尾部进行减治时，需要$Theta(n)$的时间才能找到`L[n-1]`。看起来单向列表应当总是在头部进行减治，然而事实却不一定是如此。

#bluetxt[实验`lreverse.cpp`。]本节将以倒置列表为例子，对两种减治方法进行比较。首先，对于双向列表的倒置，我们可以直接从头尾两个方向遍历，交换对称的两个节点的数据域。这种做法和向量上的做法一致，也可以使用`std::reverse`。

```cpp
void operator()(List<T>& L) override {
    auto l { L.begin() }, r { --L.end() };
    for (auto n { L.size() }; n >= 2; n -= 2) {
        std::iter_swap(l++, r--);
    }
}
```

#h(2em)下面讨论单向列表（为了方便比较仍然使用`List<T>`作为参数，但不允许使用前向指针），首先考虑在头部进行减治的情况。按照减治的思想，在将`L[0]`摘出列表之后，把从`L[1]`开始的剩余列表反转，然后再进行合并：把被摘出的`L[0]`接到反转后的剩余列表的尾部，如 @fig:lis9 所示。

#figure(
    image("images/lis9.svg", width: 50%),
    caption: "使用头部减治法倒置单向列表",
) <fig:lis9>

```cpp
void reverse(List<T>& L) {
    if (L.size() <= 1) {
        return;
    }
    auto first { std::move(*L.begin()) };
    L.pop_front();
    reverse(L);
    L.push_back(first);
}
```

#h(2em)它的时间复杂度和空间复杂度均为$Theta(n)$。这个算法并不是尾递归，这意味着我们将它改写成迭代的时候会遇到困难。这一困难来自于我们在做递归调用的时候，需要保存当前递归实例摘出的元素`first`。当我们进行到最后一层递归调用的时候，需要保存之前每一次摘出的元素，这就意味着不可避免地需要$Theta(n)$的空间。这也就意味着，将此方法改写为迭代之后，几乎和下面的“极端”做法等价。

```cpp
void operator()(List<T>& L) override {
    Vector<T> V(L.size());
    std::move(L.begin(), L.end(), V.begin());
    std::reverse(V.begin(), V.end());
    std::move(V.begin(), V.end(), L.begin());
}
```

#h(2em)这个做法的时间复杂度和空间复杂度同样都是$Theta(n)$。它将所有元素移动到一个辅助向量里，在向量里面倒置，再移动回列表里。我们很难接受这样的算法。从刚才的分析中已经可以发现，影响空间效率的主要原因是，单向列表只有后向指针。当在头部进行减治的时候，被提取出来的`L[0]`彻底和`L[1:n]`断开，无法通过`L[1:n]`上的指针找到`L[0]`，从而必须要额外的空间来存储它。于是就可以想到，是否可以利用单向列表的_不对称性_，采用在尾部进行减治的策略设计算法？答案是肯定的。当在尾部进行减治的时候，我们可以先处理`L[0:n-1]`，然后利用`L[n-1]`的后向指针直接找到`L[n]`。下面展示了一个示例代码（已隐藏前向指针的相关赋值操作），其原理如@fig:lis10 所示。


#figure(
    image("images/lis10.svg", width: 75%),
    caption: "使用尾部减治法倒置单向列表",
) <fig:lis10>

```cpp
iterator reverse(iterator head, std::size_t sz) {
    if (sz <= 1) {
        return ++head;
    }
    auto p { reverse(head, sz - 1) };
    auto q { p + 1 }, r { q + 1 };
    auto tmp { std::move(p.node()->next()) };
    p.node()->next() = std::move(q.node()->next());
    q.node()->next() = std::move(head.node()->next());
    head.node()->next() = std::move(tmp);
    return p;
}
void operator()(List<T>& L) override {
    reverse(--L.begin(), L.size());
}
```

#h(2em)上面的示例代码虽然使用了`--L.begin()`，但这个迭代器在单向列表的场合中也可以通过头哨兵指针得到，并没有和不使用前向指针的约束相违背。这份代码虽然不是尾递归，但它很容易被改写为迭代。这是因为，如果将减治的过程分成“处理减治项”和“合并”两个阶段，则上述算法中，合并所用到的信息都可以在处理完减治项之后得到，而不需要再处理减治项之前预先保存。因此，我们可以使用固定的变量存储每次递归调用的参数和返回值，从而将减治的过程变为“平凡项$arrow.r$合并1$arrow.r$合并2$arrow.r ...$”的迭代过程。一个示例的迭代写法如下所示。

```cpp
void operator()(List<T>& L) override {
    auto head { --L.begin() }, p { head + 1 };
    for (auto i { 1uz }; i < L.size(); ++i) {
        auto q { p + 1 }, r { q + 1 };
        auto tmp { std::move(p.node()->next()) };
        p.node()->next() = std::move(q.node()->next());
        q.node()->next() = std::move(head.node()->next());
        head.node()->next() = std::move(tmp);
    }
}
```

#h(2em)上述算法的时间复杂度为$Theta(n)$，空间复杂度为$O(1)$。此外，这是一个针对指针域进行操作的算法，在整个算法过程中，只有各个后向指针的指向发生了变化，而每个节点内部的数据域没有变化，也没有创建或删除节点。

#figure(table(
    columns: 5,
    $n$, [数据域\ 直接交换], [数据域\ 转移到向量], [指针域\ 头部减治], [指针域\ 尾部减治],
    [$10^5$], [0], [1], [栈溢出], [0],
    [$10^6$], [8], [29], [栈溢出], [14],
    [$10^7$], [84], [263], [栈溢出], [136],
),
    caption: "顺序删除和随机删除的耗时对比",
) <tab:lis3>

另一方面，利用`std::reverse`逐个交换双向列表中对称的节点上的数据，则是针对数据域进行操作的算法。在整个算法过程中，只有各个节点内部的数据域发生了变化，而没有改变每个节点的指针指向关系，也没有创建或删除节点。

*针对指针域*和*针对数据域*，是设计列表算法时的两种不同路径。针对指针域的算法将列表上的节点当做一个整体，通过修改指针来改变节点在列表中的顺序。针对数据域的算法则将列表当做一个访问受限（只能访问已知位置的直接前驱和直接后继）的向量处理。如果一个向量上的算法没有涉及循秩访问，那就可以原封不动地迁移到列表上。涉及循秩访问的算法如折半查找则不适用。这种做法显得非常投机取巧，但效率却不一定低，在现实程序开发中不失为一种选择。

== 列表的归并排序 <lis:merge-sort>

本节讨论在列表上做归并排序，这是一个比较复杂的列表操作。
一种基本的思路是针对数据域的归并排序。从迭代器的观点看，向量和列表作为线性表具有高度的相似性，所以无论是双向列表还是单向列表，都可以使用和@vec:merge-sort 或@vec:merge-sort-bottom-up 一样的方法进行归并排序。唯一的区别在于向量的迭代器支持随机访问，而列表无法支持这一点。因此，在我们想要找到中点的时候，向量的版本可以直接使用左边界和右边界的平均值，而列表的版本只能传入一个规模并手动向前查找；幸运的是，迭代的时间是$Theta(n)$的，和归并的时间相同，因此不会引入更高的时间复杂度。

=== 针对指针域的归并排序

显然，上面这种归并排序没能发挥列表的特点。在归并的时候，没有必要使用快慢指针，而是可以充分利用列表的灵活性，达到不需要辅助空间的效果。比如，原先的列表可以分成`L`和`R`两部分，为了对列表`L`$arrow.r$`R`进行排序，我们可以首先将它切断成两个独立的列表`L`和`R`，递归地分别排序之后，再根据`L`和`R`的首节点大小关系，将它们重新连接起来，如@fig:lis5 所示。

#figure(
    image("images/lis5.svg", width: 75%),
    caption: "针对指针域的归并排序",
) <fig:lis5>

针对数据域的归并排序在整个排序过程中没有修改任何节点的相对位置，只是改动了每个节点里的数据元素的值。因此这个版本的实现和向量相同，因为向量也不能改变数据单元的相对位置，向量中相对位置和绝对位置（地址）是统一的。而对于针对指针域的归并排序，在整个排序过程中，每个节点的值都没有被修改，被改动的只有节点的前向和后向指针，从而改变节点的相对位置。这是在@邓俊辉2013数据结构 中介绍的版本，原理仍然是归并排序，但归并的实现和向量的版本完全不同。

哨兵节点在这个版本的归并排序里会产生麻烦，因为它们会破坏拆分后的列表结构。如@fig:lis5 所示，如果在拆分列表前不分离哨兵节点，则拆分后的前后两段，一个只有头节点，一个只有尾节点，需要各自单独判断；如果先分离哨兵节点再拆分，则两段都既没有头节点也没有尾节点，不需要单独判断。当数据区域被排序完成之后，再将头尾节点接入即可。值得一提的是，@fig:lis5 中的`H`和`T`并不代表整个列表的哨兵节点，当递归地对列表的一部分进行排序时，`H`和`T`是这一部分的第一个节点的直接前驱、最后一个节点的直接后继，或者说这一部分的哨兵节点。

```cpp
using node_ptr = std::unique_ptr<typename L<T>::node_type>;
constexpr node_ptr&& ptr(iterator pos) {
    return std::move((--pos).node()->next());
}
void connect(iterator& prev, node_ptr& next) {
    next->prev() = prev.node();
    prev.node()->next() = std::move(next);
    next = std::move((++prev).node()->next());
}
iterator merge(iterator lo, iterator mi, iterator hi) {
    auto plo { ptr(lo) }, pmi { ptr(mi) }, tail { ptr(hi) };
    auto head { lo - 1 }, last { head };
    while (plo && pmi) {
        if (cmp(pmi->data(), plo->data())) {
            connect(last, pmi);
        } else {
            connect(last, plo);
        }
    }
    while (plo) {
        connect(last, plo);
    }
    while (pmi) {
        connect(last, pmi);
    }
    tail->prev() = last.node();
    last.node()->next() = std::move(tail);
    return ++head;
}
iterator mergeSort(iterator lo, iterator hi, std::size_t sz) {
    if (sz <= 1) return;
    auto mi { lo + sz / 2 };
    lo = mergeSort(lo, mi, sz / 2);
    mi = mergeSort(mi, hi, sz - sz / 2);
    return merge(lo, mi, hi);
}
void sort(L<T>& l) override {
    mergeSort(l.begin(), l.end(), l.size());
}
```

#graybox[【C++学习】#linebreak()#h(2em)
C++11开始允许程序员定义`constexpr`修饰的函数，并在每个版本的C++中不断扩大允许`constexpr`函数修饰的范围。`constexpr`函数被用于在编译期计算常量表达式，从而提高程序在运行期的性能。极端情况下，程序员可以在编译期计算出能够为问题范围内所有输入提供输出的一张表，从而在运行期直接查表得到结果，即使用编译时间和编译出的可执行文件大小来换取运行时间的降低。

`constexpr`函数现在被用于替换几乎所有的C语言风格宏（macro）。宏是一种在预处理阶段被展开的文本替换，它不是真正的函数，因此不具有函数的类型检查、作用域等特性。相比之下，`constexpr`函数则是真正的函数，它可以被编译器检查、优化，也可以被调试器调试。因此，现在的C++程序员应当尽量避免使用宏，而使用`constexpr`函数。

一般的宏主要用于下列4个场景：
+ 定义一些常量。此类宏应当被改写为`constexpr`常量，如：
    ```cpp
    #define PI 3.14159265358979323846             // not recommended
    constexpr auto pi { 3.14159265358979323846 }; // recommended
    ```
+ 定义一个枚举类型。此类宏应当被改写为`enum`类型，如：
    ```cpp
    #define COLOR_RED 0
    #define COLOR_GREEN 1
    #define COLOR_BLUE 2                   // not recommended
    enum class Color { Red, Green, Blue }; // recommended
    ```
+ 定义一些简单的函数。此类宏应当被改写为`constexpr`函数，如：
    ```cpp
    #define MAX(a, b) ((a) > (b) ? (a) : (b)) // not recommended
    constexpr auto max(auto a, auto b) {      // recommended
        return a > b ? a : b;
    }
    ```
+ 条件编译。函数体内的条件编译可改为`if constexpr`，但全局的条件编译目前仍然没有替代方案。
]

=== 归并排序的性能差异

#bluetxt[实验`lmergesort.cpp`。]针对指针域的归并排序将空间复杂度从$Theta(n)$降低到了$Theta(log n)$（一定要注意递归本身的空间复杂度，不能误以为是$O(1)$），那么显然它会在时间上有所损失。为了评估归并排序的性能差异，我们设计了一个实验。

#figure(table(
    columns: 9,
    [$n$], [向量], [向量], [列表], [列表], [列表], [列表], [列表], [列表],
    [方向], [$arrow.b$], [$arrow.t$], [$arrow.b$], [$arrow.t$], [$arrow.b$], [$arrow.b$], [$arrow.t$], [$arrow.b$],
    [字段], [数据], [数据], [数据], [数据], [指针], [数据], [数据], [指针],
    [随机化], [-], [-], [否], [否], [否], [是], [是], [是],
    [$10^4$], [0], [0], [1], [1], [1], [1], [1], [1],
    [$10^5$], [11], [11], [19], [19], [23], [50], [121], [37],
    [$10^6$], [133], [132], [277], [483], [596], [1882], [3663], [1274],
),
    caption: "归并排序的耗时对比",
) <tab:lis4>

如@tab:lis4 所示，我们对比三个归并排序，分别为针对数据域的方法实现的归并排序（自上而下和自下而上版本），以及针对指针域的归并排序。实验结果表明，和向量的情况不同，在列表的场合，自下而上的归并排序消耗的时间会显著高于自上而下的归并排序。这是因为，自上而下版本的一些归并段的左右端点来自递归调用的参数，只有中点需要自己找；自下而上版本因为没有递归，所以在已知左端点的情况下，需要自己找中点和右端点。在循秩访问的向量中，这只是多了一次加法，时间消耗可以忽略不计；而在循位置访问的列表中，找端点需要循着后向指针一个一个找，时间消耗就明显增加了。自上而下的版本用时明显比向量归并排序多，一定程度上也来自于这个原因。

另一个影响归并排序效率的重要因素来自于数据的局部性。实验中提供了一个`shuffle`方法，用于将列表中的节点随机打乱。是否调用该方法和不调用会大幅影响实验结果。在不调用`shuffle`的情况下，自下而上的版本就会和自上而下版本有一定的差距，而针对指针域的版本在`n`较大的情况下会更慢。这是因为不随机打乱的时候，列表中的节点是连续生成的，因此针对数据域的排序能利用到局部性，而针对指针域的排序在排序过程中会将节点次序打乱，从而丧失局部性。

在调用了`shuffle`的情况下，情况会发生变化。所有版本的列表归并排序都会因为损失局部性而性能降低。由于循着后向指针一个一个找的过程没有了局部性，自下而上版本和自上而下版本的差距会进一步拉大。针对指针域的归并排序因为移动指针本来就会破坏局部性，受到的影响比较小。因此，如果列表的节点是随机生成的或者已经经过了长期维护，无法保证局部性，那么针对指针域的归并排序会变成一个比较好的选择。

== 循环列表 <lis:circular-list>

// === 循环列表的结构 <lis:circular-list-structure>

*循环列表*（circular list）基于循环链表，后者是普通的、线性的链表的一个变体。简单地说，循环列表就是舍弃了头节点和尾节点，让第一个节点`L[0]`的前向指针指向最后一个节点`L[n-1]`，让最后一个节点`L[n-1]`的后向指针指向第一个节点`L[0]`，首尾相连，形成的环状结构。循环列表同样可以分为单向循环列表和双向循环列表。循环列表的三种基本操作和@lis:insert-find-remove 介绍的普通线性列表几乎完全一致，所以不再赘述。

#figure(
    image("images/lis6.svg", width: 60%),
    caption: "循环列表的结构",
) <fig:lis6>

@fig:lis6 展示了单向循环列表和双向循环列表的结构。由于需要保证列表的节点首尾相连，所以无法在循环列表的环上嵌入哨兵节点。@fig:lis6 中的`head`称为*头指针*，它是一个指向列表中第一个元素的裸指针；类似地，也可以（可选地）用一个*尾指针*指向列表中的最后一个元素。

注意到，如果循环列表中只有一个元素，那么它的后向指针（双向循环列表中，也包括前向指针）将指向自己，因此它持有自身的所有权。当使用@lis:remove 介绍的普通线性列表的删除方法去删除循环列表中唯一的一个元素时，会无法释放这个唯一元素的空间。因此，对最后一个元素进行删除的时候需要进行特判。同理，在对一个空的循环列表插入第一个元素时，也需要进行特判。此外，由于没有哨兵节点的存在，当循环列表在头部进行操作的时候，需要特别地对头指针进行维护；如果启用了尾指针，那么在尾部进行操作的时候，也需要特别地对尾指针进行维护；这些维护的行为都会给代码设计造成更大的负担，同时也使得程序运行过程中增加了一定数量的判断，影响列表的性能。测试程序位于#bluetxt[`clist.cpp`]。

循环列表的主要特征是：循环列表上的指针沿着前向指针或后向指针走下去，就可以在列表上_无限轮询_每个节点。#bluetxt[`clistit.cpp`]展示了一个例子。这种无限轮询的特点使它在《网络原理》和《操作系统》中的一些“持续性维护”的情景中有用武之地，但在《数据结构》中不常用。

#pagebreak()

// 这个算是算法问题，不算数据结构问题，现在先删了
// === 约瑟夫问题 <lis:josephus>

// #bluetxt[实验`josephus.cpp`。]
// 循环列表的主要特征是：循环列表上的指针沿着前向指针或后向指针走下去，就可以在列表上_无限轮询_每个节点。这种无限轮询的特点使它在《网络原理》和《操作系统》中的一些“持续性维护”的情景中有用武之地，但在《数据结构》中不常用。本节将介绍一个经典的问题：约瑟夫（Josephus）问题。它基于循环列表的模型，但是使用循环列表解决的方法是相对低效的。

// 约瑟夫问题的描述如下：有`n`个人围成一圈，从第一个人开始报数，报到`m`的人出列，然后从出列的下一个人开始重新报数，直到所有人都出列。求最后一个出列的人的编号。这个问题的解法有很多种，其中一种是使用循环列表。我们可以将`n`个人的编号依次插入到循环列表中，然后从第一个人开始，每次移动`m-1`步，直到列表中只剩下一个人。

// ```cpp
// std::size_t operator()(std::size_t n, std::size_t m) {
//     for (auto i { 0uz }; i < n; ++i) {
//         L.push_back(i);
//     }
//     for (auto p { L.begin() }; L.size() > 1; ) {
//         p = L.erase(p + (m - 1));
//     }
//     return L.front();
// }
// ```

// #h(2em)这个模型下，循环列表具有显著的优势：一方面，因为首尾相接，所以可以通过`p + (m-1)`直接让迭代器（循环地）向后移动`m-1`步，而如果采用普通的线性列表，则每次只能向后移动1步，然后就需要判断是否到达末尾，到达末尾的情况下再重置回开头。另一方面，借助列表的特性，`erase`方法是$O(1)$的，因此整个算法的时间复杂度是$Theta(m n)$的，空间复杂度则为$Theta(n)$；如果采用向量，虽然可以借助强大的循秩访问迭代器来快速完成向后移动`m-1`的操作，但每次进行`erase`方法需要的时间是$O(n)$的，时间复杂度为$Theta(n^2)$。

== 静态列表 <lis:static-list>

*静态列表*（static list）指的是基于数组实现的列表（或者也可以基于向量实现，从而允许扩容）。列表在建立的时候，申请一块连续的内存，所有的节点都存在这部分内存中。与向量有所区别的是，节点的相对位置可以和它们在数组里的位置不同。在静态列表中，前向指针和后向指针往往用所基于的数组（向量）中的下标代替，因此，静态列表虽然本质上是一种循位置访问的结构（列表），但它的位置是用秩表示的，因为列表中的节点存在数组或向量里。

和动态分配内存的动态列表相比，由于装填因子的问题，静态列表需要消耗更多的空间，所以它非常不常用（仅出现在不提供指针/引用语法的古代编程语言中）。但在小型程序的设计中（如算法竞赛），由于动态分配内存可能会引起时间消耗上的不确定性，并且此时程序可以使用的空间几乎总是绰绰有余的，所以静态列表仍然有发挥的空间。

单链/双链、线性/循环、动态/静态，这三对关系是相互独立的，可以组成8种不同结构的列表实现。在本节将以双链、线性为例，介绍静态列表的实现方法。为了支持扩容，这里基于向量实现。由于静态列表和动态列表非常相似，这里只介绍静态列表的特有特点。

=== 静态列表上的节点

和动态列表不同，静态列表用来存储前向指针和后向指针的类型变成了秩。

```cpp
template <typename T>
class StaticListNode {
    T m_data;
    std::size_t m_prev { 0 };
    std::size_t m_next { 0 };
};
```

#h(2em)静态列表节点中的前向指针和后向指针，只是指示其直接前驱和直接后继的节点在静态列表用于存储所有节点的向量中的位置，而不实际对这些节点进行内存管理。因此，静态列表中的节点不需要显式写出构造函数，并且其复制和移动语义都可以是默认的。对于秩而言，我们需要指定特殊值用来对应指针情形中的空指针。在这里，我们认为秩为0表示指向空；因此在实现静态列表的时候，我们不能使用秩为0的数据单元来存放数据，否则会产生混淆。当然，也可以规定一个不可能出现的值（比如-1），或者使用`std::optional<std::size_t>`代替裸的`std::size_t`来表示秩。除了秩为0的单元外，我们还需要规定固定的单元用来存放头节点和尾节点。所以，对于有哨兵节点的静态列表，需要至少3个固定的、和数据单元无关的单元用来存放节点。这类单元被称为*元数据*（metadata），和普通的数据（data）单元相对。

```cpp

template <typename T>
class StaticList : public AbstractStaticList<T> {
    Vector<node_type> m_nodes {};
    static constexpr std::size_t NIL { 0 };
    static constexpr std::size_t HEAD { 1 };
    static constexpr std::size_t TAIL { 2 };
    node_type& node(std::size_t index) override {
        return m_nodes[index];
    }
};
```

#h(2em)这里，我们采用了一个`node`方法在用于表示位置的秩和实际节点之间建立联系。静态列表的操作和动态列表相比大同小异，因为不需要考虑智能指针的所有权问题，静态列表可以更加随意一些，比如，下面是静态列表的后插实现。

```cpp
iterator insertAsNext(iterator p, const T& e) override {
    iterator q { this, m_nodes.size() };
    auto r { p + 1 };
    m_nodes.push_back(node_type { e, p.index(), r.index() });
    p.node().next() = q.index();
    r.node().prev() = q.index();
    return q;
}
```

#h(2em) 在上述后插实现中，我们先构造了一个节点`q`，将其前向和后向指针接在`p`和`r`之间，然后再将`p`的后向指针和`r`的前向指针接在`q`上。

=== 在静态列表上删除一个元素

如果我们按照动态列表的方法在静态列表上删除，可以得到下面的算法。

```cpp
iterator erase(iterator p) override {
    auto q { p - 1 }, r { p + 1 };
    q.node().next() = r.index();
    r.node().prev() = q.index();
}
```

#h(2em)上述算法存在一个致命的问题：被删除的节点的内存无法被释放。设列表用来存储所有节点的向量为`V`，则因为被删除的节点在向量`V`中、由向量进行内存管理，所以不能直接释放内存。所以，需要将被删除的节点从向量`V`中删除，以释放`V`中的空间，使其可以被分配给其他节点。然而，直接调用向量的删除元素方法也是不行的。因为删除`V[0:n]`中的一个节点`V[r]`，会导致它的后缀`V[r+1:n]`整体前移。`V[r+1:n]`的前移会导致这些节点的秩发生变化，如果其他节点的前向或后向指针指向了它们，则需要更新这些指针。所以，如果用从`V`中删除节点的方式来清理内存，则删除一个节点的时间复杂度高达$Theta(n-r)=O(n)$，这是列表所不能允许的。如果用这种方法来删除列表上的节点，那还不如直接使用向量来存储。

为了将删除节点的影响降到最低，我们希望`r`越大越好。当`r=n-1`（被删除的节点在向量末尾）时，$Theta(n-r)=O(1)$，这是列表所理想的结果。因为列表的元素次序和`V`中的元素次序无关，所以您可以很自然地想到，只需要将`V[r]`交换到`V[n-1]`，就可以顺利在$O(1)$的时间内删除了。//一个可能的实现原理如图\ref{fig:lis7}所示。

```cpp
iterator erase(iterator p) override {
    auto q { p - 1 }, r { p + 1 };
    q.node().next() = r.index();
    r.node().prev() = q.index();
    if (iterator s { this, m_node.size() - 1 }; p != s) {
        p.node() = std::move(s.node());
        (p - 1).node().next() = p.index();
        (p + 1).node().prev() = p.index();
    }
    m_nodes.pop_back();
    return r;
}
```

#h(2em)对于元素次序不重要的向量结构，在执行删除时，可以将被删除的元素移动到向量末尾再删除，可以将删除操作的时间复杂度从$Theta(n-r)$降低为$O(1)$，这是一个常用的技巧。在后面的章节中还会再次出现。测试程序位于#bluetxt[`slist.cpp`]。// TODO: 移动到末尾再删除的技巧

根据我们在@lis:remove 中的经验，这种对数据域的直接操作是不安全的。如果有一个迭代器指向`V[n-1]`，那么当我们删除了前面的一个节点之后，这个迭代器就会失效，而该迭代器的持有者并不能了解到这一点。我们希望克服这个困难。为了保证迭代器不失效，我们就不能针对数据域做操作，只能针对指针域做操作。因此，在删除一个节点`V[r]`的时候，被释放的空间只能是`V[r]`本身，并且为了保证时间复杂度，我们不能让`V[r+1:n]`整体前移，需要用一个其他机制来标识`V[r]`已经被释放。

一个自然的想法是，我们将“已经被释放”的节点的秩全都记录下来。当插入一个新元素时，如果有“已经被释放”的节点，就从中取出一个节点来使用，而不是直接在向量末尾插入。这样，我们就可以保证向量中的节点是连续的，而且不会有空洞。这种方法被称为*对象池*（object pool）。需要注意，在使用对象池的时候，不再能够用`V.size()`减去元数据单元数量来获得列表的规模，而需要额外维护一个规模变量。使用对象池创建节点对象时，采用下面的方法。

```cpp
Vector<std::size_t> m_free {};
iterator create() {
    ++m_size;
    if (m_free.empty()) {
        m_nodes.push_back(node_type {});
        return iterator { this, m_nodes.size() - 1 };
    } else {
        auto index { m_free.back() };
        m_free.pop_back();
        return iterator { this, index };
    }
}
```

#h(2em)这样，我们在删除一个节点的时候，只需要将它的秩加入到`m_free`中即可，既不会导致迭代器失效，也不会导致时间复杂度增加。这种方法的时间复杂度是$O(1)$，但是空间复杂度会增加$O(n)$。

== 本章习题 <lis:exercises>

在 @lis:structure 中：#linebreak()
+ #easy 假设元素被访问的概率均等，则列表的循秩访问平均时间复杂度是多少？
+ #easy 为什么没有尾节点的单向列表无法支持`push_back`操作？
+ #medium 如果采用裸指针而不是智能指针来实现单向列表节点的`next`字段，则单向列表中有可能会出现环。给定单向列表的头节点，设计一个算法判断是否存在环，并分析其时间复杂度。
+ #medium 裸指针也有可能造成两个节点指向同一个节点的情况。已知节点`a`和节点`b`有某个公共后继`c`，即`a`$... arrow.r$`c`$arrow.l ...$`b`。设计一个算法找到`c`，并分析其时间复杂度。
+ #medium 双向列表中的每个数据域需要对应2个指针域。修改双向列表使得每个数据域只需要对应1个指针域，从而节约空间。

#h(2em)在 @lis:insert-find-remove 中：#linebreak()
+ #easy 在没有哨兵节点的情况下，后插一个元素需要进行哪些特判？
+ #easy 写出采用裸指针的单向列表的后插、前插和删除算法。
+ #easy 写出单向列表的`erase_after`方法，删除在所给迭代器的直接后继。
+ #easy 如何在有序列表上做唯一化？和向量有什么不同？
+ #medium 双向列表可以通过`insertAsPred(begin(), e)`实现在头部插入元素。单向列表如果使用该方法在头部插入元素，会存在什么问题？如何解决这个问题？ 
+ #easy 设计一个算法，将一个列表整体插入到另一个列表的指定位置（前插）。
+ #medium 设计一个算法，让同一列表中的节点`p`和节点`q`的位置互换，要求时间复杂度为$O(1)$。请注意是节点互换，而不是节点数据互换。
+ #medium 由于CPU执行指令是有次序的，因此软件算法通常假定两个语句的执行时刻不同，比如`a = b, b = a`这样的语句会使得`a`被赋值为`b`，而`b`并不会被赋值为（原先的）`a`。#linebreak()但是，基于触发器的硬件语句并不遵循这个规则，比如在某个时钟上升沿，触发`a = b, b = a`，则寄存器`a`和`b`的值会_交换_。现在希望模拟硬件上同时触发的行为，给定一个向量`V[0:n]`和`k`个形如`V[i] = V[j]`的更新语句，假定这些语句在同一时刻触发，将触发后的结果更新在向量`V`上。已知`k`远小于`n`，设计一个算法，将这些语句的触发行为模拟出来，并分析其时间复杂度。

#h(2em) 在 @lis:reverse 中：#linebreak()
+ #easy 写出双向列表通过针对指针域的操作实现的倒置算法。
+ #medium 头部减治算法的示例程序涉及到了创建和删除节点，修改该程序，让它也成为一个针对指针域进行操作的算法。
+ #easy 如果列表没有`size`方法，修改尾部减治算法，使其不需要通过预先进行一次遍历来获取列表的规模。
+ #medium 如果没有哨兵节点，是否仍然可以使用尾部减治策略，在单向列表上进行倒置操作？请给出一个算法。

#h(2em) 在 @lis:merge-sort 中：#linebreak()
+ #easy 针对指针域的归并排序是否可以用来改写自下而上的归并排序算法？
+ #medium 在针对指针域的归并排序中，指针的所有权管理会增加问题的难度。如果使用裸指针代替`std::unique_ptr`，则不需要考虑断链引起节点被释放的问题，该算法可以得到一定的简化。请给出一个使用裸指针的归并排序算法。
+ #hard 在针对指针域的归并排序中，示例代码会使用到节点的前向指针，从而无法直接应用在单向列表上。修改该算法使得它可以在单向列表上应用。

#h(2em) 在 @lis:circular-list 中：#linebreak()
+ #easy 如果循环列表上有哨兵节点，会造成哪些不利影响？
+ #easy 如何向一个空的循环列表插入第一个元素？
+ #easy 如何从一个单元素的循环列表删除最后一个元素？
+ #easy 什么情况下，循环列表的头指针需要更新？如果启用了尾指针，那么什么情况下，循环列表的尾指针需要更新？
+ #medium 设计一个算法反转单向的循环列表。
+ #medium 约瑟夫（Josephus）问题：有`n`个人围成一圈，从第一个人开始报数，报到`m`的人出列，然后从出列的下一个人开始重新报数，直到所有人都出列。求最后一个出列的人的编号。请使用循环列表实现该算法，并分析其时间复杂度。
+ #hard 约瑟夫问题实际上不需要模拟，可以通过_减治_的方法解决，从而得到$Theta(n)$甚至$O(k log n)$的算法，设计一个这样的算法，并分析其时间复杂度。
// + #medium 约瑟夫问题的另一种解法是使用向量模拟。请实现这个算法，并分析其时间复杂度。
// + #hard 实际上约瑟夫问题的解决不需要借助模拟的方法，而是可以通过减治方法解决。一种减治方法是：每趟删除$floor(n/m)$个元素，对于原来的$n$个元素，可以得到一个新的$n - floor(n/m)$个元素的约瑟夫问题。在`n`远大于`m`的情况下，这种方法可以大大减少时间复杂度。请实现这个算法，并分析其时间复杂度。
// + #hard 如果`n < m`，则上述方法无法每趟删除多个元素，从而性能受到影响。在这种情况下，可以每次删除一个元素进行减治，从而得到$Theta(n)$的算法。请实现这个算法。

// #h(2em) 在 @lis:josephus 中：#linebreak()
// + #medium 证明使用向量模拟解决约瑟夫问题的时间复杂度为$Theta(n^2)$。
// + #hard 联系@vec:remove-value 所介绍的按条件删除方法，向量模拟解决约瑟夫问题时可以借助快慢指针每趟删除$floor(n/m)$个元素。实现该算法并分析其时间复杂度。

#h(2em) 在 @lis:static-list 中：
+ #easy 双向列表的后插操作总是包括了4个指针的赋值。在静态列表和动态列表的后插操作中，这4个指针的赋值分别需要满足什么顺序条件？
+ #medium 采用`m_free`实现的对象池需要$O(n)$的额外空间。有一个方法可以避免空间上的浪费：由于`m_nodes`中“已经被释放”的节点仍然带有`prev`和`next`两个指针，我们可以借助这两个指针将对象池里的节点也连接成一个列表，从而只需要$O(1)$的额外空间来存这个列表的第一个节点的秩即可。请实现这个方法并分析它和`m_free`的优劣。

#linebreak() #v(-1.5em)

== 本章小结 <lis:summary>

和向量相比，列表的链式结构显得不那么直观，在列表上进行插入、删除等操作时对指针的多次赋值，对初学者而言颇有难度。本书采用智能指针实现列表，为读者提供了一个不同于经典教材的视角：所有权视角。每个节点被且仅被一个智能指针持有所有权，我希望这一特性使得读者能够在设计链表操作的时候能够有迹可循（尽管在实际程序设计中您可能使用的是裸指针）。下面列出了本章的一些学习目标。

+ 您学会了绘制列表的指针关系图，通过图形设计算法。
+ 您了解到哨兵节点在列表中的作用。
+ 您学会了采用后向智能指针控制列表节点所有权，并能从所有权的视角触发设计指针赋值操作序列，注意避免“断链”和“迭代器失效”的问题。
+ 您了解到列表作为线性递归定义的数据结构，适合使用减治策略设计算法。
+ 您了解到设计列表上的算法时，可以有针对数据域和针对指针域两种路径。


#figure(table(
    columns: 4,
    [], [向量], [双向列表], [单向列表],
    [存储连续], [√], [×], [×],
    [性能稳定], [×], [√], [√],
    [增删灵活], [×], [√], [〇],
    [位置安全], [〇], [√], [×],
    [节约空间], [√], [×], [〇]
),
    caption: "归并排序的耗时对比",
) <tab:lis5>

向量和列表的区别也是一个重要的问题。本书从插入、删除和归并排序等几种典型场景出发，对向量、双向列表和单向列表的区别作出了分析。在@tab:lis5 中提供了几个视角，读者可以根据自己的理解，列出更加全面的对比表格。
